<?php
/**
 * BuildApi
 * PHP version 5
 *
 * @category Class
 * @package  AceViral\TeamCity
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * TeamCity REST API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2018.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.24-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace AceViral\TeamCity\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use AceViral\TeamCity\ApiException;
use AceViral\TeamCity\Configuration;
use AceViral\TeamCity\HeaderSelector;
use AceViral\TeamCity\ObjectSerializer;

/**
 * BuildApi Class Doc Comment
 *
 * @category Class
 * @package  AceViral\TeamCity
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class BuildApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addBuildVcsLabel
     *
     * Add a VCS label to the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $locator locator (optional)
     * @param  string $fields fields (optional)
     * @param  string $body body (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\VcsLabels
     */
    public function addBuildVcsLabel($build_locator, $locator = null, $fields = null, $body = null)
    {
        list($response) = $this->addBuildVcsLabelWithHttpInfo($build_locator, $locator, $fields, $body);
        return $response;
    }

    /**
     * Operation addBuildVcsLabelWithHttpInfo
     *
     * Add a VCS label to the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  string $body (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\VcsLabels, HTTP status code, HTTP response headers (array of strings)
     */
    public function addBuildVcsLabelWithHttpInfo($build_locator, $locator = null, $fields = null, $body = null)
    {
        $returnType = '\AceViral\TeamCity\Model\VcsLabels';
        $request = $this->addBuildVcsLabelRequest($build_locator, $locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\VcsLabels',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addBuildVcsLabelAsync
     *
     * Add a VCS label to the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addBuildVcsLabelAsync($build_locator, $locator = null, $fields = null, $body = null)
    {
        return $this->addBuildVcsLabelAsyncWithHttpInfo($build_locator, $locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addBuildVcsLabelAsyncWithHttpInfo
     *
     * Add a VCS label to the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addBuildVcsLabelAsyncWithHttpInfo($build_locator, $locator = null, $fields = null, $body = null)
    {
        $returnType = '\AceViral\TeamCity\Model\VcsLabels';
        $request = $this->addBuildVcsLabelRequest($build_locator, $locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addBuildVcsLabel'
     *
     * @param  string $build_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addBuildVcsLabelRequest($build_locator, $locator = null, $fields = null, $body = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling addBuildVcsLabel'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/vcsLabels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addLogMessageToBuild
     *
     * Adds a message to the build log. Service messages are accepted.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function addLogMessageToBuild($build_locator, $body = null, $fields = null)
    {
        $this->addLogMessageToBuildWithHttpInfo($build_locator, $body, $fields);
    }

    /**
     * Operation addLogMessageToBuildWithHttpInfo
     *
     * Adds a message to the build log. Service messages are accepted.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function addLogMessageToBuildWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '';
        $request = $this->addLogMessageToBuildRequest($build_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation addLogMessageToBuildAsync
     *
     * Adds a message to the build log. Service messages are accepted.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addLogMessageToBuildAsync($build_locator, $body = null, $fields = null)
    {
        return $this->addLogMessageToBuildAsyncWithHttpInfo($build_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addLogMessageToBuildAsyncWithHttpInfo
     *
     * Adds a message to the build log. Service messages are accepted.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addLogMessageToBuildAsyncWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '';
        $request = $this->addLogMessageToBuildRequest($build_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addLogMessageToBuild'
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addLogMessageToBuildRequest($build_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling addLogMessageToBuild'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/log';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addProblemToBuild
     *
     * Add a build problem to the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\ProblemOccurrence
     */
    public function addProblemToBuild($build_locator, $body = null, $fields = null)
    {
        list($response) = $this->addProblemToBuildWithHttpInfo($build_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation addProblemToBuildWithHttpInfo
     *
     * Add a build problem to the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\ProblemOccurrence, HTTP status code, HTTP response headers (array of strings)
     */
    public function addProblemToBuildWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\ProblemOccurrence';
        $request = $this->addProblemToBuildRequest($build_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\ProblemOccurrence',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addProblemToBuildAsync
     *
     * Add a build problem to the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addProblemToBuildAsync($build_locator, $body = null, $fields = null)
    {
        return $this->addProblemToBuildAsyncWithHttpInfo($build_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addProblemToBuildAsyncWithHttpInfo
     *
     * Add a build problem to the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addProblemToBuildAsyncWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\ProblemOccurrence';
        $request = $this->addProblemToBuildRequest($build_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addProblemToBuild'
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addProblemToBuildRequest($build_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling addProblemToBuild'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/problemOccurrences';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addTagsToBuild
     *
     * Add tags to the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  \AceViral\TeamCity\Model\Tags $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\Tags
     */
    public function addTagsToBuild($build_locator, $body = null, $fields = null)
    {
        list($response) = $this->addTagsToBuildWithHttpInfo($build_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation addTagsToBuildWithHttpInfo
     *
     * Add tags to the matching build.
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\Tags $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\Tags, HTTP status code, HTTP response headers (array of strings)
     */
    public function addTagsToBuildWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Tags';
        $request = $this->addTagsToBuildRequest($build_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\Tags',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addTagsToBuildAsync
     *
     * Add tags to the matching build.
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\Tags $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addTagsToBuildAsync($build_locator, $body = null, $fields = null)
    {
        return $this->addTagsToBuildAsyncWithHttpInfo($build_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addTagsToBuildAsyncWithHttpInfo
     *
     * Add tags to the matching build.
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\Tags $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addTagsToBuildAsyncWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Tags';
        $request = $this->addTagsToBuildRequest($build_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addTagsToBuild'
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\Tags $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addTagsToBuildRequest($build_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling addTagsToBuild'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addTagsToMultipleBuilds
     *
     * Add tags to multiple matching builds.
     *
     * @param  string $build_locator build_locator (required)
     * @param  \AceViral\TeamCity\Model\Tags $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\MultipleOperationResult
     */
    public function addTagsToMultipleBuilds($build_locator, $body = null, $fields = null)
    {
        list($response) = $this->addTagsToMultipleBuildsWithHttpInfo($build_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation addTagsToMultipleBuildsWithHttpInfo
     *
     * Add tags to multiple matching builds.
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\Tags $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\MultipleOperationResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function addTagsToMultipleBuildsWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\MultipleOperationResult';
        $request = $this->addTagsToMultipleBuildsRequest($build_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\MultipleOperationResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addTagsToMultipleBuildsAsync
     *
     * Add tags to multiple matching builds.
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\Tags $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addTagsToMultipleBuildsAsync($build_locator, $body = null, $fields = null)
    {
        return $this->addTagsToMultipleBuildsAsyncWithHttpInfo($build_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addTagsToMultipleBuildsAsyncWithHttpInfo
     *
     * Add tags to multiple matching builds.
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\Tags $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addTagsToMultipleBuildsAsyncWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\MultipleOperationResult';
        $request = $this->addTagsToMultipleBuildsRequest($build_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addTagsToMultipleBuilds'
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\Tags $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addTagsToMultipleBuildsRequest($build_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling addTagsToMultipleBuilds'
            );
        }

        $resourcePath = '/app/rest/builds/multiple/{buildLocator}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelBuild
     *
     * cancelBuild
     *
     * @param  string $build_locator build_locator (required)
     * @param  \AceViral\TeamCity\Model\BuildCancelRequest $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\Build
     */
    public function cancelBuild($build_locator, $body = null, $fields = null)
    {
        list($response) = $this->cancelBuildWithHttpInfo($build_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation cancelBuildWithHttpInfo
     *
     * cancelBuild
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\BuildCancelRequest $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\Build, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelBuildWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Build';
        $request = $this->cancelBuildRequest($build_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\Build',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cancelBuildAsync
     *
     * cancelBuild
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\BuildCancelRequest $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelBuildAsync($build_locator, $body = null, $fields = null)
    {
        return $this->cancelBuildAsyncWithHttpInfo($build_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelBuildAsyncWithHttpInfo
     *
     * cancelBuild
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\BuildCancelRequest $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelBuildAsyncWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Build';
        $request = $this->cancelBuildRequest($build_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelBuild'
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\BuildCancelRequest $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelBuildRequest($build_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling cancelBuild'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelMultiple
     *
     * cancelMultipleBuilds
     *
     * @param  string $build_locator build_locator (required)
     * @param  \AceViral\TeamCity\Model\BuildCancelRequest $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\MultipleOperationResult
     */
    public function cancelMultiple($build_locator, $body = null, $fields = null)
    {
        list($response) = $this->cancelMultipleWithHttpInfo($build_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation cancelMultipleWithHttpInfo
     *
     * cancelMultipleBuilds
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\BuildCancelRequest $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\MultipleOperationResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelMultipleWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\MultipleOperationResult';
        $request = $this->cancelMultipleRequest($build_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\MultipleOperationResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cancelMultipleAsync
     *
     * cancelMultipleBuilds
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\BuildCancelRequest $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelMultipleAsync($build_locator, $body = null, $fields = null)
    {
        return $this->cancelMultipleAsyncWithHttpInfo($build_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelMultipleAsyncWithHttpInfo
     *
     * cancelMultipleBuilds
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\BuildCancelRequest $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelMultipleAsyncWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\MultipleOperationResult';
        $request = $this->cancelMultipleRequest($build_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelMultiple'
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\BuildCancelRequest $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelMultipleRequest($build_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling cancelMultiple'
            );
        }

        $resourcePath = '/app/rest/builds/multiple/{buildLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteBuild
     *
     * Delete build matching the locator.
     *
     * @param  string $build_locator build_locator (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteBuild($build_locator)
    {
        $this->deleteBuildWithHttpInfo($build_locator);
    }

    /**
     * Operation deleteBuildWithHttpInfo
     *
     * Delete build matching the locator.
     *
     * @param  string $build_locator (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBuildWithHttpInfo($build_locator)
    {
        $returnType = '';
        $request = $this->deleteBuildRequest($build_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteBuildAsync
     *
     * Delete build matching the locator.
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBuildAsync($build_locator)
    {
        return $this->deleteBuildAsyncWithHttpInfo($build_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteBuildAsyncWithHttpInfo
     *
     * Delete build matching the locator.
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBuildAsyncWithHttpInfo($build_locator)
    {
        $returnType = '';
        $request = $this->deleteBuildRequest($build_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteBuild'
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteBuildRequest($build_locator)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling deleteBuild'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteBuildComment
     *
     * Remove the build comment matching the locator.
     *
     * @param  string $build_locator build_locator (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteBuildComment($build_locator)
    {
        $this->deleteBuildCommentWithHttpInfo($build_locator);
    }

    /**
     * Operation deleteBuildCommentWithHttpInfo
     *
     * Remove the build comment matching the locator.
     *
     * @param  string $build_locator (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBuildCommentWithHttpInfo($build_locator)
    {
        $returnType = '';
        $request = $this->deleteBuildCommentRequest($build_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteBuildCommentAsync
     *
     * Remove the build comment matching the locator.
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBuildCommentAsync($build_locator)
    {
        return $this->deleteBuildCommentAsyncWithHttpInfo($build_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteBuildCommentAsyncWithHttpInfo
     *
     * Remove the build comment matching the locator.
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBuildCommentAsyncWithHttpInfo($build_locator)
    {
        $returnType = '';
        $request = $this->deleteBuildCommentRequest($build_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteBuildComment'
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteBuildCommentRequest($build_locator)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling deleteBuildComment'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/comment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMultipleBuildComments
     *
     * Delete comments of multiple matching builds.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\MultipleOperationResult
     */
    public function deleteMultipleBuildComments($build_locator, $fields = null)
    {
        list($response) = $this->deleteMultipleBuildCommentsWithHttpInfo($build_locator, $fields);
        return $response;
    }

    /**
     * Operation deleteMultipleBuildCommentsWithHttpInfo
     *
     * Delete comments of multiple matching builds.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\MultipleOperationResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteMultipleBuildCommentsWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\MultipleOperationResult';
        $request = $this->deleteMultipleBuildCommentsRequest($build_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\MultipleOperationResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteMultipleBuildCommentsAsync
     *
     * Delete comments of multiple matching builds.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMultipleBuildCommentsAsync($build_locator, $fields = null)
    {
        return $this->deleteMultipleBuildCommentsAsyncWithHttpInfo($build_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMultipleBuildCommentsAsyncWithHttpInfo
     *
     * Delete comments of multiple matching builds.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMultipleBuildCommentsAsyncWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\MultipleOperationResult';
        $request = $this->deleteMultipleBuildCommentsRequest($build_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMultipleBuildComments'
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteMultipleBuildCommentsRequest($build_locator, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling deleteMultipleBuildComments'
            );
        }

        $resourcePath = '/app/rest/builds/multiple/{buildLocator}/comment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteMultipleBuilds
     *
     * Delete multiple builds matching the locator.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\MultipleOperationResult
     */
    public function deleteMultipleBuilds($build_locator, $fields = null)
    {
        list($response) = $this->deleteMultipleBuildsWithHttpInfo($build_locator, $fields);
        return $response;
    }

    /**
     * Operation deleteMultipleBuildsWithHttpInfo
     *
     * Delete multiple builds matching the locator.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\MultipleOperationResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteMultipleBuildsWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\MultipleOperationResult';
        $request = $this->deleteMultipleBuildsRequest($build_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\MultipleOperationResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteMultipleBuildsAsync
     *
     * Delete multiple builds matching the locator.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMultipleBuildsAsync($build_locator, $fields = null)
    {
        return $this->deleteMultipleBuildsAsyncWithHttpInfo($build_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteMultipleBuildsAsyncWithHttpInfo
     *
     * Delete multiple builds matching the locator.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteMultipleBuildsAsyncWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\MultipleOperationResult';
        $request = $this->deleteMultipleBuildsRequest($build_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteMultipleBuilds'
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteMultipleBuildsRequest($build_locator, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling deleteMultipleBuilds'
            );
        }

        $resourcePath = '/app/rest/builds/multiple/{buildLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadFileOfBuild
     *
     * Download specific file.
     *
     * @param  string $path path (required)
     * @param  string $build_locator build_locator (required)
     * @param  bool $resolve_parameters resolve_parameters (optional)
     * @param  bool $log_build_usage log_build_usage (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function downloadFileOfBuild($path, $build_locator, $resolve_parameters = null, $log_build_usage = null)
    {
        $this->downloadFileOfBuildWithHttpInfo($path, $build_locator, $resolve_parameters, $log_build_usage);
    }

    /**
     * Operation downloadFileOfBuildWithHttpInfo
     *
     * Download specific file.
     *
     * @param  string $path (required)
     * @param  string $build_locator (required)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadFileOfBuildWithHttpInfo($path, $build_locator, $resolve_parameters = null, $log_build_usage = null)
    {
        $returnType = '';
        $request = $this->downloadFileOfBuildRequest($path, $build_locator, $resolve_parameters, $log_build_usage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation downloadFileOfBuildAsync
     *
     * Download specific file.
     *
     * @param  string $path (required)
     * @param  string $build_locator (required)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadFileOfBuildAsync($path, $build_locator, $resolve_parameters = null, $log_build_usage = null)
    {
        return $this->downloadFileOfBuildAsyncWithHttpInfo($path, $build_locator, $resolve_parameters, $log_build_usage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadFileOfBuildAsyncWithHttpInfo
     *
     * Download specific file.
     *
     * @param  string $path (required)
     * @param  string $build_locator (required)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadFileOfBuildAsyncWithHttpInfo($path, $build_locator, $resolve_parameters = null, $log_build_usage = null)
    {
        $returnType = '';
        $request = $this->downloadFileOfBuildRequest($path, $build_locator, $resolve_parameters, $log_build_usage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadFileOfBuild'
     *
     * @param  string $path (required)
     * @param  string $build_locator (required)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function downloadFileOfBuildRequest($path, $build_locator, $resolve_parameters = null, $log_build_usage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling downloadFileOfBuild'
            );
        }
        if (!preg_match("/(\/.*)?/", $path)) {
            throw new \InvalidArgumentException("invalid value for \"path\" when calling BuildApi.downloadFileOfBuild, must conform to the pattern /(\/.*)?/.");
        }

        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling downloadFileOfBuild'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/artifacts/files{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($resolve_parameters !== null) {
            $queryParams['resolveParameters'] = ObjectSerializer::toQueryValue($resolve_parameters);
        }
        // query params
        if ($log_build_usage !== null) {
            $queryParams['logBuildUsage'] = ObjectSerializer::toQueryValue($log_build_usage);
        }

        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAggregatedBuildStatus
     *
     * Get the build status of aggregated matching builds.
     *
     * @param  string $build_locator build_locator (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getAggregatedBuildStatus($build_locator)
    {
        list($response) = $this->getAggregatedBuildStatusWithHttpInfo($build_locator);
        return $response;
    }

    /**
     * Operation getAggregatedBuildStatusWithHttpInfo
     *
     * Get the build status of aggregated matching builds.
     *
     * @param  string $build_locator (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAggregatedBuildStatusWithHttpInfo($build_locator)
    {
        $returnType = 'string';
        $request = $this->getAggregatedBuildStatusRequest($build_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAggregatedBuildStatusAsync
     *
     * Get the build status of aggregated matching builds.
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAggregatedBuildStatusAsync($build_locator)
    {
        return $this->getAggregatedBuildStatusAsyncWithHttpInfo($build_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAggregatedBuildStatusAsyncWithHttpInfo
     *
     * Get the build status of aggregated matching builds.
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAggregatedBuildStatusAsyncWithHttpInfo($build_locator)
    {
        $returnType = 'string';
        $request = $this->getAggregatedBuildStatusRequest($build_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAggregatedBuildStatus'
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAggregatedBuildStatusRequest($build_locator)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getAggregatedBuildStatus'
            );
        }

        $resourcePath = '/app/rest/builds/aggregated/{buildLocator}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAggregatedBuildStatusIcon
     *
     * Get the status icon (in specified format) of aggregated matching builds.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $suffix suffix (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getAggregatedBuildStatusIcon($build_locator, $suffix)
    {
        $this->getAggregatedBuildStatusIconWithHttpInfo($build_locator, $suffix);
    }

    /**
     * Operation getAggregatedBuildStatusIconWithHttpInfo
     *
     * Get the status icon (in specified format) of aggregated matching builds.
     *
     * @param  string $build_locator (required)
     * @param  string $suffix (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAggregatedBuildStatusIconWithHttpInfo($build_locator, $suffix)
    {
        $returnType = '';
        $request = $this->getAggregatedBuildStatusIconRequest($build_locator, $suffix);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getAggregatedBuildStatusIconAsync
     *
     * Get the status icon (in specified format) of aggregated matching builds.
     *
     * @param  string $build_locator (required)
     * @param  string $suffix (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAggregatedBuildStatusIconAsync($build_locator, $suffix)
    {
        return $this->getAggregatedBuildStatusIconAsyncWithHttpInfo($build_locator, $suffix)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAggregatedBuildStatusIconAsyncWithHttpInfo
     *
     * Get the status icon (in specified format) of aggregated matching builds.
     *
     * @param  string $build_locator (required)
     * @param  string $suffix (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAggregatedBuildStatusIconAsyncWithHttpInfo($build_locator, $suffix)
    {
        $returnType = '';
        $request = $this->getAggregatedBuildStatusIconRequest($build_locator, $suffix);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAggregatedBuildStatusIcon'
     *
     * @param  string $build_locator (required)
     * @param  string $suffix (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAggregatedBuildStatusIconRequest($build_locator, $suffix)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getAggregatedBuildStatusIcon'
            );
        }
        // verify the required parameter 'suffix' is set
        if ($suffix === null || (is_array($suffix) && count($suffix) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $suffix when calling getAggregatedBuildStatusIcon'
            );
        }
        if (!preg_match("/(.*)?/", $suffix)) {
            throw new \InvalidArgumentException("invalid value for \"suffix\" when calling BuildApi.getAggregatedBuildStatusIcon, must conform to the pattern /(.*)?/.");
        }


        $resourcePath = '/app/rest/builds/aggregated/{buildLocator}/statusIcon{suffix}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }
        // path params
        if ($suffix !== null) {
            $resourcePath = str_replace(
                '{' . 'suffix' . '}',
                ObjectSerializer::toPathValue($suffix),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllBuilds
     *
     * Get all builds.
     *
     * @param  string $locator locator (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\Builds
     */
    public function getAllBuilds($locator = null, $fields = null)
    {
        list($response) = $this->getAllBuildsWithHttpInfo($locator, $fields);
        return $response;
    }

    /**
     * Operation getAllBuildsWithHttpInfo
     *
     * Get all builds.
     *
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\Builds, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllBuildsWithHttpInfo($locator = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Builds';
        $request = $this->getAllBuildsRequest($locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\Builds',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllBuildsAsync
     *
     * Get all builds.
     *
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllBuildsAsync($locator = null, $fields = null)
    {
        return $this->getAllBuildsAsyncWithHttpInfo($locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllBuildsAsyncWithHttpInfo
     *
     * Get all builds.
     *
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllBuildsAsyncWithHttpInfo($locator = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Builds';
        $request = $this->getAllBuildsRequest($locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllBuilds'
     *
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllBuildsRequest($locator = null, $fields = null)
    {

        $resourcePath = '/app/rest/builds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArtifactDependencyChanges
     *
     * Get artifact dependency changes of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\BuildChanges
     */
    public function getArtifactDependencyChanges($build_locator, $fields = null)
    {
        list($response) = $this->getArtifactDependencyChangesWithHttpInfo($build_locator, $fields);
        return $response;
    }

    /**
     * Operation getArtifactDependencyChangesWithHttpInfo
     *
     * Get artifact dependency changes of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\BuildChanges, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArtifactDependencyChangesWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\BuildChanges';
        $request = $this->getArtifactDependencyChangesRequest($build_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\BuildChanges',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArtifactDependencyChangesAsync
     *
     * Get artifact dependency changes of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArtifactDependencyChangesAsync($build_locator, $fields = null)
    {
        return $this->getArtifactDependencyChangesAsyncWithHttpInfo($build_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArtifactDependencyChangesAsyncWithHttpInfo
     *
     * Get artifact dependency changes of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArtifactDependencyChangesAsyncWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\BuildChanges';
        $request = $this->getArtifactDependencyChangesRequest($build_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArtifactDependencyChanges'
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArtifactDependencyChangesRequest($build_locator, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getArtifactDependencyChanges'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/artifactDependencyChanges';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArtifactsDirectory
     *
     * Get the artifacts' directory of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getArtifactsDirectory($build_locator)
    {
        list($response) = $this->getArtifactsDirectoryWithHttpInfo($build_locator);
        return $response;
    }

    /**
     * Operation getArtifactsDirectoryWithHttpInfo
     *
     * Get the artifacts' directory of the matching build.
     *
     * @param  string $build_locator (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArtifactsDirectoryWithHttpInfo($build_locator)
    {
        $returnType = 'string';
        $request = $this->getArtifactsDirectoryRequest($build_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArtifactsDirectoryAsync
     *
     * Get the artifacts' directory of the matching build.
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArtifactsDirectoryAsync($build_locator)
    {
        return $this->getArtifactsDirectoryAsyncWithHttpInfo($build_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArtifactsDirectoryAsyncWithHttpInfo
     *
     * Get the artifacts' directory of the matching build.
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArtifactsDirectoryAsyncWithHttpInfo($build_locator)
    {
        $returnType = 'string';
        $request = $this->getArtifactsDirectoryRequest($build_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArtifactsDirectory'
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArtifactsDirectoryRequest($build_locator)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getArtifactsDirectory'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/artifactsDirectory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuild
     *
     * Get build matching the locator.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\Build
     */
    public function getBuild($build_locator, $fields = null)
    {
        list($response) = $this->getBuildWithHttpInfo($build_locator, $fields);
        return $response;
    }

    /**
     * Operation getBuildWithHttpInfo
     *
     * Get build matching the locator.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\Build, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Build';
        $request = $this->getBuildRequest($build_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\Build',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildAsync
     *
     * Get build matching the locator.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildAsync($build_locator, $fields = null)
    {
        return $this->getBuildAsyncWithHttpInfo($build_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildAsyncWithHttpInfo
     *
     * Get build matching the locator.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildAsyncWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Build';
        $request = $this->getBuildRequest($build_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuild'
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildRequest($build_locator, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getBuild'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildActualParameters
     *
     * Get actual build parameters of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\Properties
     */
    public function getBuildActualParameters($build_locator, $fields = null)
    {
        list($response) = $this->getBuildActualParametersWithHttpInfo($build_locator, $fields);
        return $response;
    }

    /**
     * Operation getBuildActualParametersWithHttpInfo
     *
     * Get actual build parameters of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\Properties, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildActualParametersWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Properties';
        $request = $this->getBuildActualParametersRequest($build_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\Properties',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildActualParametersAsync
     *
     * Get actual build parameters of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildActualParametersAsync($build_locator, $fields = null)
    {
        return $this->getBuildActualParametersAsyncWithHttpInfo($build_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildActualParametersAsyncWithHttpInfo
     *
     * Get actual build parameters of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildActualParametersAsyncWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Properties';
        $request = $this->getBuildActualParametersRequest($build_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildActualParameters'
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildActualParametersRequest($build_locator, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getBuildActualParameters'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/resulting-properties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildField
     *
     * Get a field of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $field field (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getBuildField($build_locator, $field)
    {
        list($response) = $this->getBuildFieldWithHttpInfo($build_locator, $field);
        return $response;
    }

    /**
     * Operation getBuildFieldWithHttpInfo
     *
     * Get a field of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $field (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildFieldWithHttpInfo($build_locator, $field)
    {
        $returnType = 'string';
        $request = $this->getBuildFieldRequest($build_locator, $field);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildFieldAsync
     *
     * Get a field of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildFieldAsync($build_locator, $field)
    {
        return $this->getBuildFieldAsyncWithHttpInfo($build_locator, $field)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildFieldAsyncWithHttpInfo
     *
     * Get a field of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildFieldAsyncWithHttpInfo($build_locator, $field)
    {
        $returnType = 'string';
        $request = $this->getBuildFieldRequest($build_locator, $field);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildField'
     *
     * @param  string $build_locator (required)
     * @param  string $field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildFieldRequest($build_locator, $field)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getBuildField'
            );
        }
        // verify the required parameter 'field' is set
        if ($field === null || (is_array($field) && count($field) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field when calling getBuildField'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/{field}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }
        // path params
        if ($field !== null) {
            $resourcePath = str_replace(
                '{' . 'field' . '}',
                ObjectSerializer::toPathValue($field),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildFinishDate
     *
     * Get the finish date of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getBuildFinishDate($build_locator)
    {
        list($response) = $this->getBuildFinishDateWithHttpInfo($build_locator);
        return $response;
    }

    /**
     * Operation getBuildFinishDateWithHttpInfo
     *
     * Get the finish date of the matching build.
     *
     * @param  string $build_locator (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildFinishDateWithHttpInfo($build_locator)
    {
        $returnType = 'string';
        $request = $this->getBuildFinishDateRequest($build_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildFinishDateAsync
     *
     * Get the finish date of the matching build.
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildFinishDateAsync($build_locator)
    {
        return $this->getBuildFinishDateAsyncWithHttpInfo($build_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildFinishDateAsyncWithHttpInfo
     *
     * Get the finish date of the matching build.
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildFinishDateAsyncWithHttpInfo($build_locator)
    {
        $returnType = 'string';
        $request = $this->getBuildFinishDateRequest($build_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildFinishDate'
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildFinishDateRequest($build_locator)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getBuildFinishDate'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/finishDate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildNumber
     *
     * Get the number of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getBuildNumber($build_locator)
    {
        list($response) = $this->getBuildNumberWithHttpInfo($build_locator);
        return $response;
    }

    /**
     * Operation getBuildNumberWithHttpInfo
     *
     * Get the number of the matching build.
     *
     * @param  string $build_locator (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildNumberWithHttpInfo($build_locator)
    {
        $returnType = 'string';
        $request = $this->getBuildNumberRequest($build_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildNumberAsync
     *
     * Get the number of the matching build.
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildNumberAsync($build_locator)
    {
        return $this->getBuildNumberAsyncWithHttpInfo($build_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildNumberAsyncWithHttpInfo
     *
     * Get the number of the matching build.
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildNumberAsyncWithHttpInfo($build_locator)
    {
        $returnType = 'string';
        $request = $this->getBuildNumberRequest($build_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildNumber'
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildNumberRequest($build_locator)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getBuildNumber'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/number';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildPinInfo
     *
     * Check if the matching build is pinned.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\PinInfo
     */
    public function getBuildPinInfo($build_locator, $fields = null)
    {
        list($response) = $this->getBuildPinInfoWithHttpInfo($build_locator, $fields);
        return $response;
    }

    /**
     * Operation getBuildPinInfoWithHttpInfo
     *
     * Check if the matching build is pinned.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\PinInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildPinInfoWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\PinInfo';
        $request = $this->getBuildPinInfoRequest($build_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\PinInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildPinInfoAsync
     *
     * Check if the matching build is pinned.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildPinInfoAsync($build_locator, $fields = null)
    {
        return $this->getBuildPinInfoAsyncWithHttpInfo($build_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildPinInfoAsyncWithHttpInfo
     *
     * Check if the matching build is pinned.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildPinInfoAsyncWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\PinInfo';
        $request = $this->getBuildPinInfoRequest($build_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildPinInfo'
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildPinInfoRequest($build_locator, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getBuildPinInfo'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/pinInfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildProblems
     *
     * Get build problems of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\ProblemOccurrences
     */
    public function getBuildProblems($build_locator, $fields = null)
    {
        list($response) = $this->getBuildProblemsWithHttpInfo($build_locator, $fields);
        return $response;
    }

    /**
     * Operation getBuildProblemsWithHttpInfo
     *
     * Get build problems of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\ProblemOccurrences, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildProblemsWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\ProblemOccurrences';
        $request = $this->getBuildProblemsRequest($build_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\ProblemOccurrences',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildProblemsAsync
     *
     * Get build problems of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildProblemsAsync($build_locator, $fields = null)
    {
        return $this->getBuildProblemsAsyncWithHttpInfo($build_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildProblemsAsyncWithHttpInfo
     *
     * Get build problems of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildProblemsAsyncWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\ProblemOccurrences';
        $request = $this->getBuildProblemsRequest($build_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildProblems'
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildProblemsRequest($build_locator, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getBuildProblems'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/problemOccurrences';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildRelatedIssues
     *
     * Get related issues of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\IssuesUsages
     */
    public function getBuildRelatedIssues($build_locator, $fields = null)
    {
        list($response) = $this->getBuildRelatedIssuesWithHttpInfo($build_locator, $fields);
        return $response;
    }

    /**
     * Operation getBuildRelatedIssuesWithHttpInfo
     *
     * Get related issues of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\IssuesUsages, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildRelatedIssuesWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\IssuesUsages';
        $request = $this->getBuildRelatedIssuesRequest($build_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\IssuesUsages',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildRelatedIssuesAsync
     *
     * Get related issues of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildRelatedIssuesAsync($build_locator, $fields = null)
    {
        return $this->getBuildRelatedIssuesAsyncWithHttpInfo($build_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildRelatedIssuesAsyncWithHttpInfo
     *
     * Get related issues of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildRelatedIssuesAsyncWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\IssuesUsages';
        $request = $this->getBuildRelatedIssuesRequest($build_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildRelatedIssues'
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildRelatedIssuesRequest($build_locator, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getBuildRelatedIssues'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/relatedIssues';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildResolved
     *
     * Get the resolvement status of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $value value (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getBuildResolved($build_locator, $value)
    {
        list($response) = $this->getBuildResolvedWithHttpInfo($build_locator, $value);
        return $response;
    }

    /**
     * Operation getBuildResolvedWithHttpInfo
     *
     * Get the resolvement status of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $value (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildResolvedWithHttpInfo($build_locator, $value)
    {
        $returnType = 'string';
        $request = $this->getBuildResolvedRequest($build_locator, $value);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildResolvedAsync
     *
     * Get the resolvement status of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildResolvedAsync($build_locator, $value)
    {
        return $this->getBuildResolvedAsyncWithHttpInfo($build_locator, $value)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildResolvedAsyncWithHttpInfo
     *
     * Get the resolvement status of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildResolvedAsyncWithHttpInfo($build_locator, $value)
    {
        $returnType = 'string';
        $request = $this->getBuildResolvedRequest($build_locator, $value);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildResolved'
     *
     * @param  string $build_locator (required)
     * @param  string $value (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildResolvedRequest($build_locator, $value)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getBuildResolved'
            );
        }
        // verify the required parameter 'value' is set
        if ($value === null || (is_array($value) && count($value) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $value when calling getBuildResolved'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/resolved/{value}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }
        // path params
        if ($value !== null) {
            $resourcePath = str_replace(
                '{' . 'value' . '}',
                ObjectSerializer::toPathValue($value),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildResultingProperties
     *
     * Update a build parameter of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $property_name property_name (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getBuildResultingProperties($build_locator, $property_name)
    {
        list($response) = $this->getBuildResultingPropertiesWithHttpInfo($build_locator, $property_name);
        return $response;
    }

    /**
     * Operation getBuildResultingPropertiesWithHttpInfo
     *
     * Update a build parameter of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $property_name (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildResultingPropertiesWithHttpInfo($build_locator, $property_name)
    {
        $returnType = 'string';
        $request = $this->getBuildResultingPropertiesRequest($build_locator, $property_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildResultingPropertiesAsync
     *
     * Update a build parameter of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $property_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildResultingPropertiesAsync($build_locator, $property_name)
    {
        return $this->getBuildResultingPropertiesAsyncWithHttpInfo($build_locator, $property_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildResultingPropertiesAsyncWithHttpInfo
     *
     * Update a build parameter of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $property_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildResultingPropertiesAsyncWithHttpInfo($build_locator, $property_name)
    {
        $returnType = 'string';
        $request = $this->getBuildResultingPropertiesRequest($build_locator, $property_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildResultingProperties'
     *
     * @param  string $build_locator (required)
     * @param  string $property_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildResultingPropertiesRequest($build_locator, $property_name)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getBuildResultingProperties'
            );
        }
        // verify the required parameter 'property_name' is set
        if ($property_name === null || (is_array($property_name) && count($property_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_name when calling getBuildResultingProperties'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/resulting-properties/{propertyName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }
        // path params
        if ($property_name !== null) {
            $resourcePath = str_replace(
                '{' . 'propertyName' . '}',
                ObjectSerializer::toPathValue($property_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildSourceFile
     *
     * Get a source file of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $file_name file_name (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getBuildSourceFile($build_locator, $file_name)
    {
        $this->getBuildSourceFileWithHttpInfo($build_locator, $file_name);
    }

    /**
     * Operation getBuildSourceFileWithHttpInfo
     *
     * Get a source file of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $file_name (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildSourceFileWithHttpInfo($build_locator, $file_name)
    {
        $returnType = '';
        $request = $this->getBuildSourceFileRequest($build_locator, $file_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildSourceFileAsync
     *
     * Get a source file of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $file_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildSourceFileAsync($build_locator, $file_name)
    {
        return $this->getBuildSourceFileAsyncWithHttpInfo($build_locator, $file_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildSourceFileAsyncWithHttpInfo
     *
     * Get a source file of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $file_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildSourceFileAsyncWithHttpInfo($build_locator, $file_name)
    {
        $returnType = '';
        $request = $this->getBuildSourceFileRequest($build_locator, $file_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildSourceFile'
     *
     * @param  string $build_locator (required)
     * @param  string $file_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildSourceFileRequest($build_locator, $file_name)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getBuildSourceFile'
            );
        }
        // verify the required parameter 'file_name' is set
        if ($file_name === null || (is_array($file_name) && count($file_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_name when calling getBuildSourceFile'
            );
        }
        if (!preg_match("/.+/", $file_name)) {
            throw new \InvalidArgumentException("invalid value for \"file_name\" when calling BuildApi.getBuildSourceFile, must conform to the pattern /.+/.");
        }


        $resourcePath = '/app/rest/builds/{buildLocator}/sources/files/{fileName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }
        // path params
        if ($file_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fileName' . '}',
                ObjectSerializer::toPathValue($file_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildStatisticValue
     *
     * Get a statistical value of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $name name (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getBuildStatisticValue($build_locator, $name)
    {
        list($response) = $this->getBuildStatisticValueWithHttpInfo($build_locator, $name);
        return $response;
    }

    /**
     * Operation getBuildStatisticValueWithHttpInfo
     *
     * Get a statistical value of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $name (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildStatisticValueWithHttpInfo($build_locator, $name)
    {
        $returnType = 'string';
        $request = $this->getBuildStatisticValueRequest($build_locator, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildStatisticValueAsync
     *
     * Get a statistical value of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildStatisticValueAsync($build_locator, $name)
    {
        return $this->getBuildStatisticValueAsyncWithHttpInfo($build_locator, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildStatisticValueAsyncWithHttpInfo
     *
     * Get a statistical value of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildStatisticValueAsyncWithHttpInfo($build_locator, $name)
    {
        $returnType = 'string';
        $request = $this->getBuildStatisticValueRequest($build_locator, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildStatisticValue'
     *
     * @param  string $build_locator (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildStatisticValueRequest($build_locator, $name)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getBuildStatisticValue'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getBuildStatisticValue'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/statistics/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildStatisticValues
     *
     * Get all statistical values of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\Properties
     */
    public function getBuildStatisticValues($build_locator, $fields = null)
    {
        list($response) = $this->getBuildStatisticValuesWithHttpInfo($build_locator, $fields);
        return $response;
    }

    /**
     * Operation getBuildStatisticValuesWithHttpInfo
     *
     * Get all statistical values of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\Properties, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildStatisticValuesWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Properties';
        $request = $this->getBuildStatisticValuesRequest($build_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\Properties',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildStatisticValuesAsync
     *
     * Get all statistical values of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildStatisticValuesAsync($build_locator, $fields = null)
    {
        return $this->getBuildStatisticValuesAsyncWithHttpInfo($build_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildStatisticValuesAsyncWithHttpInfo
     *
     * Get all statistical values of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildStatisticValuesAsyncWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Properties';
        $request = $this->getBuildStatisticValuesRequest($build_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildStatisticValues'
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildStatisticValuesRequest($build_locator, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getBuildStatisticValues'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/statistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildStatusIcon
     *
     * Get the status icon (in specified format) of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $suffix suffix (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getBuildStatusIcon($build_locator, $suffix)
    {
        $this->getBuildStatusIconWithHttpInfo($build_locator, $suffix);
    }

    /**
     * Operation getBuildStatusIconWithHttpInfo
     *
     * Get the status icon (in specified format) of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $suffix (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildStatusIconWithHttpInfo($build_locator, $suffix)
    {
        $returnType = '';
        $request = $this->getBuildStatusIconRequest($build_locator, $suffix);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildStatusIconAsync
     *
     * Get the status icon (in specified format) of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $suffix (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildStatusIconAsync($build_locator, $suffix)
    {
        return $this->getBuildStatusIconAsyncWithHttpInfo($build_locator, $suffix)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildStatusIconAsyncWithHttpInfo
     *
     * Get the status icon (in specified format) of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $suffix (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildStatusIconAsyncWithHttpInfo($build_locator, $suffix)
    {
        $returnType = '';
        $request = $this->getBuildStatusIconRequest($build_locator, $suffix);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildStatusIcon'
     *
     * @param  string $build_locator (required)
     * @param  string $suffix (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildStatusIconRequest($build_locator, $suffix)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getBuildStatusIcon'
            );
        }
        // verify the required parameter 'suffix' is set
        if ($suffix === null || (is_array($suffix) && count($suffix) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $suffix when calling getBuildStatusIcon'
            );
        }
        if (!preg_match("/(.*)?/", $suffix)) {
            throw new \InvalidArgumentException("invalid value for \"suffix\" when calling BuildApi.getBuildStatusIcon, must conform to the pattern /(.*)?/.");
        }


        $resourcePath = '/app/rest/builds/{buildLocator}/statusIcon{suffix}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }
        // path params
        if ($suffix !== null) {
            $resourcePath = str_replace(
                '{' . 'suffix' . '}',
                ObjectSerializer::toPathValue($suffix),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildStatusText
     *
     * Get the build status text of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getBuildStatusText($build_locator)
    {
        list($response) = $this->getBuildStatusTextWithHttpInfo($build_locator);
        return $response;
    }

    /**
     * Operation getBuildStatusTextWithHttpInfo
     *
     * Get the build status text of the matching build.
     *
     * @param  string $build_locator (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildStatusTextWithHttpInfo($build_locator)
    {
        $returnType = 'string';
        $request = $this->getBuildStatusTextRequest($build_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildStatusTextAsync
     *
     * Get the build status text of the matching build.
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildStatusTextAsync($build_locator)
    {
        return $this->getBuildStatusTextAsyncWithHttpInfo($build_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildStatusTextAsyncWithHttpInfo
     *
     * Get the build status text of the matching build.
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildStatusTextAsyncWithHttpInfo($build_locator)
    {
        $returnType = 'string';
        $request = $this->getBuildStatusTextRequest($build_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildStatusText'
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildStatusTextRequest($build_locator)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getBuildStatusText'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/statusText';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildTags
     *
     * Get tags of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $locator locator (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\Tags
     */
    public function getBuildTags($build_locator, $locator = null, $fields = null)
    {
        list($response) = $this->getBuildTagsWithHttpInfo($build_locator, $locator, $fields);
        return $response;
    }

    /**
     * Operation getBuildTagsWithHttpInfo
     *
     * Get tags of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\Tags, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildTagsWithHttpInfo($build_locator, $locator = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Tags';
        $request = $this->getBuildTagsRequest($build_locator, $locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\Tags',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildTagsAsync
     *
     * Get tags of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildTagsAsync($build_locator, $locator = null, $fields = null)
    {
        return $this->getBuildTagsAsyncWithHttpInfo($build_locator, $locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildTagsAsyncWithHttpInfo
     *
     * Get tags of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildTagsAsyncWithHttpInfo($build_locator, $locator = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Tags';
        $request = $this->getBuildTagsRequest($build_locator, $locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildTags'
     *
     * @param  string $build_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildTagsRequest($build_locator, $locator = null, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getBuildTags'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildTestOccurrences
     *
     * Get test occurrences of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\TestOccurrences
     */
    public function getBuildTestOccurrences($build_locator, $fields = null)
    {
        list($response) = $this->getBuildTestOccurrencesWithHttpInfo($build_locator, $fields);
        return $response;
    }

    /**
     * Operation getBuildTestOccurrencesWithHttpInfo
     *
     * Get test occurrences of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\TestOccurrences, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildTestOccurrencesWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\TestOccurrences';
        $request = $this->getBuildTestOccurrencesRequest($build_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\TestOccurrences',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildTestOccurrencesAsync
     *
     * Get test occurrences of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildTestOccurrencesAsync($build_locator, $fields = null)
    {
        return $this->getBuildTestOccurrencesAsyncWithHttpInfo($build_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildTestOccurrencesAsyncWithHttpInfo
     *
     * Get test occurrences of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildTestOccurrencesAsyncWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\TestOccurrences';
        $request = $this->getBuildTestOccurrencesRequest($build_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildTestOccurrences'
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildTestOccurrencesRequest($build_locator, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getBuildTestOccurrences'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/testOccurrences';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildVcsLabels
     *
     * Get VCS labels of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\VcsLabels
     */
    public function getBuildVcsLabels($build_locator, $fields = null)
    {
        list($response) = $this->getBuildVcsLabelsWithHttpInfo($build_locator, $fields);
        return $response;
    }

    /**
     * Operation getBuildVcsLabelsWithHttpInfo
     *
     * Get VCS labels of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\VcsLabels, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildVcsLabelsWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\VcsLabels';
        $request = $this->getBuildVcsLabelsRequest($build_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\VcsLabels',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildVcsLabelsAsync
     *
     * Get VCS labels of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildVcsLabelsAsync($build_locator, $fields = null)
    {
        return $this->getBuildVcsLabelsAsyncWithHttpInfo($build_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildVcsLabelsAsyncWithHttpInfo
     *
     * Get VCS labels of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildVcsLabelsAsyncWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\VcsLabels';
        $request = $this->getBuildVcsLabelsRequest($build_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildVcsLabels'
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildVcsLabelsRequest($build_locator, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getBuildVcsLabels'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/vcsLabels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCanceledInfo
     *
     * Check if the matching build is canceled.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\Comment
     */
    public function getCanceledInfo($build_locator, $fields = null)
    {
        list($response) = $this->getCanceledInfoWithHttpInfo($build_locator, $fields);
        return $response;
    }

    /**
     * Operation getCanceledInfoWithHttpInfo
     *
     * Check if the matching build is canceled.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\Comment, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCanceledInfoWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Comment';
        $request = $this->getCanceledInfoRequest($build_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\Comment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getCanceledInfoAsync
     *
     * Check if the matching build is canceled.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCanceledInfoAsync($build_locator, $fields = null)
    {
        return $this->getCanceledInfoAsyncWithHttpInfo($build_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCanceledInfoAsyncWithHttpInfo
     *
     * Check if the matching build is canceled.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCanceledInfoAsyncWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Comment';
        $request = $this->getCanceledInfoRequest($build_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCanceledInfo'
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCanceledInfoRequest($build_locator, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getCanceledInfo'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/canceledInfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFileMetadataOfBuild
     *
     * Get metadata of specific file.
     *
     * @param  string $path path (required)
     * @param  string $build_locator build_locator (required)
     * @param  string $fields fields (optional)
     * @param  bool $resolve_parameters resolve_parameters (optional)
     * @param  bool $log_build_usage log_build_usage (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\\SplFileObject
     */
    public function getFileMetadataOfBuild($path, $build_locator, $fields = null, $resolve_parameters = null, $log_build_usage = null)
    {
        list($response) = $this->getFileMetadataOfBuildWithHttpInfo($path, $build_locator, $fields, $resolve_parameters, $log_build_usage);
        return $response;
    }

    /**
     * Operation getFileMetadataOfBuildWithHttpInfo
     *
     * Get metadata of specific file.
     *
     * @param  string $path (required)
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\\SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileMetadataOfBuildWithHttpInfo($path, $build_locator, $fields = null, $resolve_parameters = null, $log_build_usage = null)
    {
        $returnType = '\AceViral\TeamCity\Model\\SplFileObject';
        $request = $this->getFileMetadataOfBuildRequest($path, $build_locator, $fields, $resolve_parameters, $log_build_usage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFileMetadataOfBuildAsync
     *
     * Get metadata of specific file.
     *
     * @param  string $path (required)
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileMetadataOfBuildAsync($path, $build_locator, $fields = null, $resolve_parameters = null, $log_build_usage = null)
    {
        return $this->getFileMetadataOfBuildAsyncWithHttpInfo($path, $build_locator, $fields, $resolve_parameters, $log_build_usage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileMetadataOfBuildAsyncWithHttpInfo
     *
     * Get metadata of specific file.
     *
     * @param  string $path (required)
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileMetadataOfBuildAsyncWithHttpInfo($path, $build_locator, $fields = null, $resolve_parameters = null, $log_build_usage = null)
    {
        $returnType = '\AceViral\TeamCity\Model\\SplFileObject';
        $request = $this->getFileMetadataOfBuildRequest($path, $build_locator, $fields, $resolve_parameters, $log_build_usage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFileMetadataOfBuild'
     *
     * @param  string $path (required)
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFileMetadataOfBuildRequest($path, $build_locator, $fields = null, $resolve_parameters = null, $log_build_usage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getFileMetadataOfBuild'
            );
        }
        if (!preg_match("/(\/.*)?/", $path)) {
            throw new \InvalidArgumentException("invalid value for \"path\" when calling BuildApi.getFileMetadataOfBuild, must conform to the pattern /(\/.*)?/.");
        }

        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getFileMetadataOfBuild'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/artifacts/metadata{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($resolve_parameters !== null) {
            $queryParams['resolveParameters'] = ObjectSerializer::toQueryValue($resolve_parameters);
        }
        // query params
        if ($log_build_usage !== null) {
            $queryParams['logBuildUsage'] = ObjectSerializer::toQueryValue($log_build_usage);
        }

        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFilesListForSubpathOfBuild
     *
     * List files under this path.
     *
     * @param  string $path path (required)
     * @param  string $build_locator build_locator (required)
     * @param  string $base_path base_path (optional)
     * @param  string $locator locator (optional)
     * @param  string $fields fields (optional)
     * @param  bool $resolve_parameters resolve_parameters (optional)
     * @param  bool $log_build_usage log_build_usage (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\Files
     */
    public function getFilesListForSubpathOfBuild($path, $build_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null, $log_build_usage = null)
    {
        list($response) = $this->getFilesListForSubpathOfBuildWithHttpInfo($path, $build_locator, $base_path, $locator, $fields, $resolve_parameters, $log_build_usage);
        return $response;
    }

    /**
     * Operation getFilesListForSubpathOfBuildWithHttpInfo
     *
     * List files under this path.
     *
     * @param  string $path (required)
     * @param  string $build_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\Files, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFilesListForSubpathOfBuildWithHttpInfo($path, $build_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null, $log_build_usage = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Files';
        $request = $this->getFilesListForSubpathOfBuildRequest($path, $build_locator, $base_path, $locator, $fields, $resolve_parameters, $log_build_usage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\Files',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFilesListForSubpathOfBuildAsync
     *
     * List files under this path.
     *
     * @param  string $path (required)
     * @param  string $build_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesListForSubpathOfBuildAsync($path, $build_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null, $log_build_usage = null)
    {
        return $this->getFilesListForSubpathOfBuildAsyncWithHttpInfo($path, $build_locator, $base_path, $locator, $fields, $resolve_parameters, $log_build_usage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFilesListForSubpathOfBuildAsyncWithHttpInfo
     *
     * List files under this path.
     *
     * @param  string $path (required)
     * @param  string $build_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesListForSubpathOfBuildAsyncWithHttpInfo($path, $build_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null, $log_build_usage = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Files';
        $request = $this->getFilesListForSubpathOfBuildRequest($path, $build_locator, $base_path, $locator, $fields, $resolve_parameters, $log_build_usage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFilesListForSubpathOfBuild'
     *
     * @param  string $path (required)
     * @param  string $build_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFilesListForSubpathOfBuildRequest($path, $build_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null, $log_build_usage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getFilesListForSubpathOfBuild'
            );
        }
        if (!preg_match("/(.*)?/", $path)) {
            throw new \InvalidArgumentException("invalid value for \"path\" when calling BuildApi.getFilesListForSubpathOfBuild, must conform to the pattern /(.*)?/.");
        }

        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getFilesListForSubpathOfBuild'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/artifacts/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($base_path !== null) {
            $queryParams['basePath'] = ObjectSerializer::toQueryValue($base_path);
        }
        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($resolve_parameters !== null) {
            $queryParams['resolveParameters'] = ObjectSerializer::toQueryValue($resolve_parameters);
        }
        // query params
        if ($log_build_usage !== null) {
            $queryParams['logBuildUsage'] = ObjectSerializer::toQueryValue($log_build_usage);
        }

        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFilesListOfBuild
     *
     * List all files.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $base_path base_path (optional)
     * @param  string $locator locator (optional)
     * @param  string $fields fields (optional)
     * @param  bool $resolve_parameters resolve_parameters (optional)
     * @param  bool $log_build_usage log_build_usage (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\Files
     */
    public function getFilesListOfBuild($build_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null, $log_build_usage = null)
    {
        list($response) = $this->getFilesListOfBuildWithHttpInfo($build_locator, $base_path, $locator, $fields, $resolve_parameters, $log_build_usage);
        return $response;
    }

    /**
     * Operation getFilesListOfBuildWithHttpInfo
     *
     * List all files.
     *
     * @param  string $build_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\Files, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFilesListOfBuildWithHttpInfo($build_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null, $log_build_usage = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Files';
        $request = $this->getFilesListOfBuildRequest($build_locator, $base_path, $locator, $fields, $resolve_parameters, $log_build_usage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\Files',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFilesListOfBuildAsync
     *
     * List all files.
     *
     * @param  string $build_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesListOfBuildAsync($build_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null, $log_build_usage = null)
    {
        return $this->getFilesListOfBuildAsyncWithHttpInfo($build_locator, $base_path, $locator, $fields, $resolve_parameters, $log_build_usage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFilesListOfBuildAsyncWithHttpInfo
     *
     * List all files.
     *
     * @param  string $build_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesListOfBuildAsyncWithHttpInfo($build_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null, $log_build_usage = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Files';
        $request = $this->getFilesListOfBuildRequest($build_locator, $base_path, $locator, $fields, $resolve_parameters, $log_build_usage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFilesListOfBuild'
     *
     * @param  string $build_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFilesListOfBuildRequest($build_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null, $log_build_usage = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getFilesListOfBuild'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/artifacts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($base_path !== null) {
            $queryParams['basePath'] = ObjectSerializer::toQueryValue($base_path);
        }
        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($resolve_parameters !== null) {
            $queryParams['resolveParameters'] = ObjectSerializer::toQueryValue($resolve_parameters);
        }
        // query params
        if ($log_build_usage !== null) {
            $queryParams['logBuildUsage'] = ObjectSerializer::toQueryValue($log_build_usage);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMultipleBuilds
     *
     * Get multiple builds matching the locator.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\Builds
     */
    public function getMultipleBuilds($build_locator, $fields = null)
    {
        list($response) = $this->getMultipleBuildsWithHttpInfo($build_locator, $fields);
        return $response;
    }

    /**
     * Operation getMultipleBuildsWithHttpInfo
     *
     * Get multiple builds matching the locator.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\Builds, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMultipleBuildsWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Builds';
        $request = $this->getMultipleBuildsRequest($build_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\Builds',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getMultipleBuildsAsync
     *
     * Get multiple builds matching the locator.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMultipleBuildsAsync($build_locator, $fields = null)
    {
        return $this->getMultipleBuildsAsyncWithHttpInfo($build_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMultipleBuildsAsyncWithHttpInfo
     *
     * Get multiple builds matching the locator.
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMultipleBuildsAsyncWithHttpInfo($build_locator, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Builds';
        $request = $this->getMultipleBuildsRequest($build_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMultipleBuilds'
     *
     * @param  string $build_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMultipleBuildsRequest($build_locator, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getMultipleBuilds'
            );
        }

        $resourcePath = '/app/rest/builds/multiple/{buildLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getZippedFileOfBuild
     *
     * Get specific file zipped.
     *
     * @param  string $path path (required)
     * @param  string $build_locator build_locator (required)
     * @param  string $base_path base_path (optional)
     * @param  string $locator locator (optional)
     * @param  string $name name (optional)
     * @param  bool $resolve_parameters resolve_parameters (optional)
     * @param  bool $log_build_usage log_build_usage (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getZippedFileOfBuild($path, $build_locator, $base_path = null, $locator = null, $name = null, $resolve_parameters = null, $log_build_usage = null)
    {
        $this->getZippedFileOfBuildWithHttpInfo($path, $build_locator, $base_path, $locator, $name, $resolve_parameters, $log_build_usage);
    }

    /**
     * Operation getZippedFileOfBuildWithHttpInfo
     *
     * Get specific file zipped.
     *
     * @param  string $path (required)
     * @param  string $build_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $name (optional)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getZippedFileOfBuildWithHttpInfo($path, $build_locator, $base_path = null, $locator = null, $name = null, $resolve_parameters = null, $log_build_usage = null)
    {
        $returnType = '';
        $request = $this->getZippedFileOfBuildRequest($path, $build_locator, $base_path, $locator, $name, $resolve_parameters, $log_build_usage);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getZippedFileOfBuildAsync
     *
     * Get specific file zipped.
     *
     * @param  string $path (required)
     * @param  string $build_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $name (optional)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getZippedFileOfBuildAsync($path, $build_locator, $base_path = null, $locator = null, $name = null, $resolve_parameters = null, $log_build_usage = null)
    {
        return $this->getZippedFileOfBuildAsyncWithHttpInfo($path, $build_locator, $base_path, $locator, $name, $resolve_parameters, $log_build_usage)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getZippedFileOfBuildAsyncWithHttpInfo
     *
     * Get specific file zipped.
     *
     * @param  string $path (required)
     * @param  string $build_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $name (optional)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getZippedFileOfBuildAsyncWithHttpInfo($path, $build_locator, $base_path = null, $locator = null, $name = null, $resolve_parameters = null, $log_build_usage = null)
    {
        $returnType = '';
        $request = $this->getZippedFileOfBuildRequest($path, $build_locator, $base_path, $locator, $name, $resolve_parameters, $log_build_usage);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getZippedFileOfBuild'
     *
     * @param  string $path (required)
     * @param  string $build_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $name (optional)
     * @param  bool $resolve_parameters (optional)
     * @param  bool $log_build_usage (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getZippedFileOfBuildRequest($path, $build_locator, $base_path = null, $locator = null, $name = null, $resolve_parameters = null, $log_build_usage = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getZippedFileOfBuild'
            );
        }
        if (!preg_match("/(\/.*)?/", $path)) {
            throw new \InvalidArgumentException("invalid value for \"path\" when calling BuildApi.getZippedFileOfBuild, must conform to the pattern /(\/.*)?/.");
        }

        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling getZippedFileOfBuild'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/artifacts/archived{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($base_path !== null) {
            $queryParams['basePath'] = ObjectSerializer::toQueryValue($base_path);
        }
        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($resolve_parameters !== null) {
            $queryParams['resolveParameters'] = ObjectSerializer::toQueryValue($resolve_parameters);
        }
        // query params
        if ($log_build_usage !== null) {
            $queryParams['logBuildUsage'] = ObjectSerializer::toQueryValue($log_build_usage);
        }

        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation markBuildAsRunning
     *
     * Starts the queued build as an agent-less build and returns the corresponding running build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\Build
     */
    public function markBuildAsRunning($build_locator, $body = null, $fields = null)
    {
        list($response) = $this->markBuildAsRunningWithHttpInfo($build_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation markBuildAsRunningWithHttpInfo
     *
     * Starts the queued build as an agent-less build and returns the corresponding running build.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\Build, HTTP status code, HTTP response headers (array of strings)
     */
    public function markBuildAsRunningWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Build';
        $request = $this->markBuildAsRunningRequest($build_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\Build',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation markBuildAsRunningAsync
     *
     * Starts the queued build as an agent-less build and returns the corresponding running build.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function markBuildAsRunningAsync($build_locator, $body = null, $fields = null)
    {
        return $this->markBuildAsRunningAsyncWithHttpInfo($build_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation markBuildAsRunningAsyncWithHttpInfo
     *
     * Starts the queued build as an agent-less build and returns the corresponding running build.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function markBuildAsRunningAsyncWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Build';
        $request = $this->markBuildAsRunningRequest($build_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'markBuildAsRunning'
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function markBuildAsRunningRequest($build_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling markBuildAsRunning'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/runningData';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pinMultipleBuilds
     *
     * Pin multiple matching builds.
     *
     * @param  string $build_locator build_locator (required)
     * @param  \AceViral\TeamCity\Model\PinInfo $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\MultipleOperationResult
     */
    public function pinMultipleBuilds($build_locator, $body = null, $fields = null)
    {
        list($response) = $this->pinMultipleBuildsWithHttpInfo($build_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation pinMultipleBuildsWithHttpInfo
     *
     * Pin multiple matching builds.
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\PinInfo $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\MultipleOperationResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function pinMultipleBuildsWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\MultipleOperationResult';
        $request = $this->pinMultipleBuildsRequest($build_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\MultipleOperationResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pinMultipleBuildsAsync
     *
     * Pin multiple matching builds.
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\PinInfo $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pinMultipleBuildsAsync($build_locator, $body = null, $fields = null)
    {
        return $this->pinMultipleBuildsAsyncWithHttpInfo($build_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pinMultipleBuildsAsyncWithHttpInfo
     *
     * Pin multiple matching builds.
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\PinInfo $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pinMultipleBuildsAsyncWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\MultipleOperationResult';
        $request = $this->pinMultipleBuildsRequest($build_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pinMultipleBuilds'
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\PinInfo $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function pinMultipleBuildsRequest($build_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling pinMultipleBuilds'
            );
        }

        $resourcePath = '/app/rest/builds/multiple/{buildLocator}/pinInfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeMultipleBuildTags
     *
     * Remove tags from multiple matching builds.
     *
     * @param  string $build_locator build_locator (required)
     * @param  \AceViral\TeamCity\Model\Tags $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\MultipleOperationResult
     */
    public function removeMultipleBuildTags($build_locator, $body = null, $fields = null)
    {
        list($response) = $this->removeMultipleBuildTagsWithHttpInfo($build_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation removeMultipleBuildTagsWithHttpInfo
     *
     * Remove tags from multiple matching builds.
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\Tags $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\MultipleOperationResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeMultipleBuildTagsWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\MultipleOperationResult';
        $request = $this->removeMultipleBuildTagsRequest($build_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\MultipleOperationResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation removeMultipleBuildTagsAsync
     *
     * Remove tags from multiple matching builds.
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\Tags $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeMultipleBuildTagsAsync($build_locator, $body = null, $fields = null)
    {
        return $this->removeMultipleBuildTagsAsyncWithHttpInfo($build_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeMultipleBuildTagsAsyncWithHttpInfo
     *
     * Remove tags from multiple matching builds.
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\Tags $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeMultipleBuildTagsAsyncWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\MultipleOperationResult';
        $request = $this->removeMultipleBuildTagsRequest($build_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeMultipleBuildTags'
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\Tags $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function removeMultipleBuildTagsRequest($build_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling removeMultipleBuildTags'
            );
        }

        $resourcePath = '/app/rest/builds/multiple/{buildLocator}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resetBuildFinishProperties
     *
     * Remove build parameters from the matching build.
     *
     * @param  string $build_locator build_locator (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function resetBuildFinishProperties($build_locator)
    {
        $this->resetBuildFinishPropertiesWithHttpInfo($build_locator);
    }

    /**
     * Operation resetBuildFinishPropertiesWithHttpInfo
     *
     * Remove build parameters from the matching build.
     *
     * @param  string $build_locator (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function resetBuildFinishPropertiesWithHttpInfo($build_locator)
    {
        $returnType = '';
        $request = $this->resetBuildFinishPropertiesRequest($build_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation resetBuildFinishPropertiesAsync
     *
     * Remove build parameters from the matching build.
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetBuildFinishPropertiesAsync($build_locator)
    {
        return $this->resetBuildFinishPropertiesAsyncWithHttpInfo($build_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resetBuildFinishPropertiesAsyncWithHttpInfo
     *
     * Remove build parameters from the matching build.
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetBuildFinishPropertiesAsyncWithHttpInfo($build_locator)
    {
        $returnType = '';
        $request = $this->resetBuildFinishPropertiesRequest($build_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resetBuildFinishProperties'
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function resetBuildFinishPropertiesRequest($build_locator)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling resetBuildFinishProperties'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/caches/finishProperties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setBuildComment
     *
     * Update the comment on the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $body body (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setBuildComment($build_locator, $body = null)
    {
        $this->setBuildCommentWithHttpInfo($build_locator, $body);
    }

    /**
     * Operation setBuildCommentWithHttpInfo
     *
     * Update the comment on the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setBuildCommentWithHttpInfo($build_locator, $body = null)
    {
        $returnType = '';
        $request = $this->setBuildCommentRequest($build_locator, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation setBuildCommentAsync
     *
     * Update the comment on the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildCommentAsync($build_locator, $body = null)
    {
        return $this->setBuildCommentAsyncWithHttpInfo($build_locator, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setBuildCommentAsyncWithHttpInfo
     *
     * Update the comment on the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildCommentAsyncWithHttpInfo($build_locator, $body = null)
    {
        $returnType = '';
        $request = $this->setBuildCommentRequest($build_locator, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setBuildComment'
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setBuildCommentRequest($build_locator, $body = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling setBuildComment'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/comment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setBuildFinishDate
     *
     * Marks the running build as finished by passing agent the current time of the build to finish.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $body body (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function setBuildFinishDate($build_locator, $body = null)
    {
        list($response) = $this->setBuildFinishDateWithHttpInfo($build_locator, $body);
        return $response;
    }

    /**
     * Operation setBuildFinishDateWithHttpInfo
     *
     * Marks the running build as finished by passing agent the current time of the build to finish.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function setBuildFinishDateWithHttpInfo($build_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->setBuildFinishDateRequest($build_locator, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setBuildFinishDateAsync
     *
     * Marks the running build as finished by passing agent the current time of the build to finish.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildFinishDateAsync($build_locator, $body = null)
    {
        return $this->setBuildFinishDateAsyncWithHttpInfo($build_locator, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setBuildFinishDateAsyncWithHttpInfo
     *
     * Marks the running build as finished by passing agent the current time of the build to finish.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildFinishDateAsyncWithHttpInfo($build_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->setBuildFinishDateRequest($build_locator, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setBuildFinishDate'
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setBuildFinishDateRequest($build_locator, $body = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling setBuildFinishDate'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/finishDate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setBuildNumber
     *
     * Update the number of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $body body (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function setBuildNumber($build_locator, $body = null)
    {
        list($response) = $this->setBuildNumberWithHttpInfo($build_locator, $body);
        return $response;
    }

    /**
     * Operation setBuildNumberWithHttpInfo
     *
     * Update the number of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function setBuildNumberWithHttpInfo($build_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->setBuildNumberRequest($build_locator, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setBuildNumberAsync
     *
     * Update the number of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildNumberAsync($build_locator, $body = null)
    {
        return $this->setBuildNumberAsyncWithHttpInfo($build_locator, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setBuildNumberAsyncWithHttpInfo
     *
     * Update the number of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildNumberAsyncWithHttpInfo($build_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->setBuildNumberRequest($build_locator, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setBuildNumber'
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setBuildNumberRequest($build_locator, $body = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling setBuildNumber'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/number';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setBuildPinInfo
     *
     * Update the pin info of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  \AceViral\TeamCity\Model\PinInfo $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\PinInfo
     */
    public function setBuildPinInfo($build_locator, $body = null, $fields = null)
    {
        list($response) = $this->setBuildPinInfoWithHttpInfo($build_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation setBuildPinInfoWithHttpInfo
     *
     * Update the pin info of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\PinInfo $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\PinInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function setBuildPinInfoWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\PinInfo';
        $request = $this->setBuildPinInfoRequest($build_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\PinInfo',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setBuildPinInfoAsync
     *
     * Update the pin info of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\PinInfo $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildPinInfoAsync($build_locator, $body = null, $fields = null)
    {
        return $this->setBuildPinInfoAsyncWithHttpInfo($build_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setBuildPinInfoAsyncWithHttpInfo
     *
     * Update the pin info of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\PinInfo $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildPinInfoAsyncWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\PinInfo';
        $request = $this->setBuildPinInfoRequest($build_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setBuildPinInfo'
     *
     * @param  string $build_locator (required)
     * @param  \AceViral\TeamCity\Model\PinInfo $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setBuildPinInfoRequest($build_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling setBuildPinInfo'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/pinInfo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setBuildStatusText
     *
     * Update the build status of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $body body (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function setBuildStatusText($build_locator, $body = null)
    {
        list($response) = $this->setBuildStatusTextWithHttpInfo($build_locator, $body);
        return $response;
    }

    /**
     * Operation setBuildStatusTextWithHttpInfo
     *
     * Update the build status of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function setBuildStatusTextWithHttpInfo($build_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->setBuildStatusTextRequest($build_locator, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setBuildStatusTextAsync
     *
     * Update the build status of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildStatusTextAsync($build_locator, $body = null)
    {
        return $this->setBuildStatusTextAsyncWithHttpInfo($build_locator, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setBuildStatusTextAsyncWithHttpInfo
     *
     * Update the build status of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildStatusTextAsyncWithHttpInfo($build_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->setBuildStatusTextRequest($build_locator, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setBuildStatusText'
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setBuildStatusTextRequest($build_locator, $body = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling setBuildStatusText'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/statusText';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setBuildTags
     *
     * Update tags of the matching build.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $locator locator (optional)
     * @param  \AceViral\TeamCity\Model\Tags $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\Tags
     */
    public function setBuildTags($build_locator, $locator = null, $body = null, $fields = null)
    {
        list($response) = $this->setBuildTagsWithHttpInfo($build_locator, $locator, $body, $fields);
        return $response;
    }

    /**
     * Operation setBuildTagsWithHttpInfo
     *
     * Update tags of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $locator (optional)
     * @param  \AceViral\TeamCity\Model\Tags $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\Tags, HTTP status code, HTTP response headers (array of strings)
     */
    public function setBuildTagsWithHttpInfo($build_locator, $locator = null, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Tags';
        $request = $this->setBuildTagsRequest($build_locator, $locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\Tags',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setBuildTagsAsync
     *
     * Update tags of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $locator (optional)
     * @param  \AceViral\TeamCity\Model\Tags $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildTagsAsync($build_locator, $locator = null, $body = null, $fields = null)
    {
        return $this->setBuildTagsAsyncWithHttpInfo($build_locator, $locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setBuildTagsAsyncWithHttpInfo
     *
     * Update tags of the matching build.
     *
     * @param  string $build_locator (required)
     * @param  string $locator (optional)
     * @param  \AceViral\TeamCity\Model\Tags $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildTagsAsyncWithHttpInfo($build_locator, $locator = null, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\Tags';
        $request = $this->setBuildTagsRequest($build_locator, $locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setBuildTags'
     *
     * @param  string $build_locator (required)
     * @param  string $locator (optional)
     * @param  \AceViral\TeamCity\Model\Tags $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setBuildTagsRequest($build_locator, $locator = null, $body = null, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling setBuildTags'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setFinishedTime
     *
     * Marks the running build as finished by passing agent the current time of the build to finish.
     *
     * @param  string $build_locator build_locator (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function setFinishedTime($build_locator)
    {
        list($response) = $this->setFinishedTimeWithHttpInfo($build_locator);
        return $response;
    }

    /**
     * Operation setFinishedTimeWithHttpInfo
     *
     * Marks the running build as finished by passing agent the current time of the build to finish.
     *
     * @param  string $build_locator (required)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function setFinishedTimeWithHttpInfo($build_locator)
    {
        $returnType = 'string';
        $request = $this->setFinishedTimeRequest($build_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setFinishedTimeAsync
     *
     * Marks the running build as finished by passing agent the current time of the build to finish.
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setFinishedTimeAsync($build_locator)
    {
        return $this->setFinishedTimeAsyncWithHttpInfo($build_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setFinishedTimeAsyncWithHttpInfo
     *
     * Marks the running build as finished by passing agent the current time of the build to finish.
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setFinishedTimeAsyncWithHttpInfo($build_locator)
    {
        $returnType = 'string';
        $request = $this->setFinishedTimeRequest($build_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setFinishedTime'
     *
     * @param  string $build_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setFinishedTimeRequest($build_locator)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling setFinishedTime'
            );
        }

        $resourcePath = '/app/rest/builds/{buildLocator}/finish';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setMultipleBuildComments
     *
     * Update comments in multiple matching builds.
     *
     * @param  string $build_locator build_locator (required)
     * @param  string $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \AceViral\TeamCity\Model\MultipleOperationResult
     */
    public function setMultipleBuildComments($build_locator, $body = null, $fields = null)
    {
        list($response) = $this->setMultipleBuildCommentsWithHttpInfo($build_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation setMultipleBuildCommentsWithHttpInfo
     *
     * Update comments in multiple matching builds.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \AceViral\TeamCity\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \AceViral\TeamCity\Model\MultipleOperationResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function setMultipleBuildCommentsWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\MultipleOperationResult';
        $request = $this->setMultipleBuildCommentsRequest($build_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AceViral\TeamCity\Model\MultipleOperationResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setMultipleBuildCommentsAsync
     *
     * Update comments in multiple matching builds.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setMultipleBuildCommentsAsync($build_locator, $body = null, $fields = null)
    {
        return $this->setMultipleBuildCommentsAsyncWithHttpInfo($build_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setMultipleBuildCommentsAsyncWithHttpInfo
     *
     * Update comments in multiple matching builds.
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setMultipleBuildCommentsAsyncWithHttpInfo($build_locator, $body = null, $fields = null)
    {
        $returnType = '\AceViral\TeamCity\Model\MultipleOperationResult';
        $request = $this->setMultipleBuildCommentsRequest($build_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setMultipleBuildComments'
     *
     * @param  string $build_locator (required)
     * @param  string $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setMultipleBuildCommentsRequest($build_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'build_locator' is set
        if ($build_locator === null || (is_array($build_locator) && count($build_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $build_locator when calling setMultipleBuildComments'
            );
        }

        $resourcePath = '/app/rest/builds/multiple/{buildLocator}/comment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($build_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'buildLocator' . '}',
                ObjectSerializer::toPathValue($build_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
