<?php
/**
 * BuildTypeApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * TeamCity REST API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2018.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.24-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * BuildTypeApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class BuildTypeApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addAgentRequirementToBuildType
     *
     * Add an agent requirement to the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \Swagger\Client\Model\AgentRequirement $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\AgentRequirement
     */
    public function addAgentRequirementToBuildType($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->addAgentRequirementToBuildTypeWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation addAgentRequirementToBuildTypeWithHttpInfo
     *
     * Add an agent requirement to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\AgentRequirement $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\AgentRequirement, HTTP status code, HTTP response headers (array of strings)
     */
    public function addAgentRequirementToBuildTypeWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\AgentRequirement';
        $request = $this->addAgentRequirementToBuildTypeRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AgentRequirement',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addAgentRequirementToBuildTypeAsync
     *
     * Add an agent requirement to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\AgentRequirement $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addAgentRequirementToBuildTypeAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->addAgentRequirementToBuildTypeAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addAgentRequirementToBuildTypeAsyncWithHttpInfo
     *
     * Add an agent requirement to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\AgentRequirement $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addAgentRequirementToBuildTypeAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\AgentRequirement';
        $request = $this->addAgentRequirementToBuildTypeRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addAgentRequirementToBuildType'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\AgentRequirement $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addAgentRequirementToBuildTypeRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addAgentRequirementToBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/agent-requirements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addArtifactDependencyToBuildType
     *
     * Add an artifact dependency to the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \Swagger\Client\Model\ArtifactDependency $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ArtifactDependency
     */
    public function addArtifactDependencyToBuildType($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->addArtifactDependencyToBuildTypeWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation addArtifactDependencyToBuildTypeWithHttpInfo
     *
     * Add an artifact dependency to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\ArtifactDependency $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ArtifactDependency, HTTP status code, HTTP response headers (array of strings)
     */
    public function addArtifactDependencyToBuildTypeWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\ArtifactDependency';
        $request = $this->addArtifactDependencyToBuildTypeRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ArtifactDependency',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addArtifactDependencyToBuildTypeAsync
     *
     * Add an artifact dependency to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\ArtifactDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addArtifactDependencyToBuildTypeAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->addArtifactDependencyToBuildTypeAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addArtifactDependencyToBuildTypeAsyncWithHttpInfo
     *
     * Add an artifact dependency to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\ArtifactDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addArtifactDependencyToBuildTypeAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\ArtifactDependency';
        $request = $this->addArtifactDependencyToBuildTypeRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addArtifactDependencyToBuildType'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\ArtifactDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addArtifactDependencyToBuildTypeRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addArtifactDependencyToBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/artifact-dependencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addBuildFeatureToBuildType
     *
     * Add build feature to the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \Swagger\Client\Model\Feature $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Feature
     */
    public function addBuildFeatureToBuildType($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->addBuildFeatureToBuildTypeWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation addBuildFeatureToBuildTypeWithHttpInfo
     *
     * Add build feature to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Feature $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Feature, HTTP status code, HTTP response headers (array of strings)
     */
    public function addBuildFeatureToBuildTypeWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Feature';
        $request = $this->addBuildFeatureToBuildTypeRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Feature',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addBuildFeatureToBuildTypeAsync
     *
     * Add build feature to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Feature $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addBuildFeatureToBuildTypeAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->addBuildFeatureToBuildTypeAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addBuildFeatureToBuildTypeAsyncWithHttpInfo
     *
     * Add build feature to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Feature $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addBuildFeatureToBuildTypeAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Feature';
        $request = $this->addBuildFeatureToBuildTypeRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addBuildFeatureToBuildType'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Feature $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addBuildFeatureToBuildTypeRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addBuildFeatureToBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addBuildStepToBuildType
     *
     * Add a build step to the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \Swagger\Client\Model\Step $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Step
     */
    public function addBuildStepToBuildType($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->addBuildStepToBuildTypeWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation addBuildStepToBuildTypeWithHttpInfo
     *
     * Add a build step to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Step $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Step, HTTP status code, HTTP response headers (array of strings)
     */
    public function addBuildStepToBuildTypeWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Step';
        $request = $this->addBuildStepToBuildTypeRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Step',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addBuildStepToBuildTypeAsync
     *
     * Add a build step to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Step $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addBuildStepToBuildTypeAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->addBuildStepToBuildTypeAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addBuildStepToBuildTypeAsyncWithHttpInfo
     *
     * Add a build step to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Step $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addBuildStepToBuildTypeAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Step';
        $request = $this->addBuildStepToBuildTypeRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addBuildStepToBuildType'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Step $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addBuildStepToBuildTypeRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addBuildStepToBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addBuildTemplate
     *
     * Add a build template to the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  \Swagger\Client\Model\BuildType $body body (optional)
     * @param  bool $optimize_settings optimize_settings (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\BuildType
     */
    public function addBuildTemplate($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        list($response) = $this->addBuildTemplateWithHttpInfo($bt_locator, $body, $optimize_settings, $fields);
        return $response;
    }

    /**
     * Operation addBuildTemplateWithHttpInfo
     *
     * Add a build template to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\BuildType $body (optional)
     * @param  bool $optimize_settings (optional)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\BuildType, HTTP status code, HTTP response headers (array of strings)
     */
    public function addBuildTemplateWithHttpInfo($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\BuildType';
        $request = $this->addBuildTemplateRequest($bt_locator, $body, $optimize_settings, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\BuildType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addBuildTemplateAsync
     *
     * Add a build template to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\BuildType $body (optional)
     * @param  bool $optimize_settings (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addBuildTemplateAsync($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        return $this->addBuildTemplateAsyncWithHttpInfo($bt_locator, $body, $optimize_settings, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addBuildTemplateAsyncWithHttpInfo
     *
     * Add a build template to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\BuildType $body (optional)
     * @param  bool $optimize_settings (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addBuildTemplateAsyncWithHttpInfo($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\BuildType';
        $request = $this->addBuildTemplateRequest($bt_locator, $body, $optimize_settings, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addBuildTemplate'
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\BuildType $body (optional)
     * @param  bool $optimize_settings (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addBuildTemplateRequest($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addBuildTemplate'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($optimize_settings !== null) {
            $queryParams['optimizeSettings'] = ObjectSerializer::toQueryValue($optimize_settings);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addParameterToBuildFeature
     *
     * Update build feature parameter for the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $feature_id feature_id (required)
     * @param  string $parameter_name parameter_name (required)
     * @param  string $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function addParameterToBuildFeature($bt_locator, $feature_id, $parameter_name, $body = null)
    {
        list($response) = $this->addParameterToBuildFeatureWithHttpInfo($bt_locator, $feature_id, $parameter_name, $body);
        return $response;
    }

    /**
     * Operation addParameterToBuildFeatureWithHttpInfo
     *
     * Update build feature parameter for the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $parameter_name (required)
     * @param  string $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function addParameterToBuildFeatureWithHttpInfo($bt_locator, $feature_id, $parameter_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->addParameterToBuildFeatureRequest($bt_locator, $feature_id, $parameter_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addParameterToBuildFeatureAsync
     *
     * Update build feature parameter for the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $parameter_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addParameterToBuildFeatureAsync($bt_locator, $feature_id, $parameter_name, $body = null)
    {
        return $this->addParameterToBuildFeatureAsyncWithHttpInfo($bt_locator, $feature_id, $parameter_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addParameterToBuildFeatureAsyncWithHttpInfo
     *
     * Update build feature parameter for the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $parameter_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addParameterToBuildFeatureAsyncWithHttpInfo($bt_locator, $feature_id, $parameter_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->addParameterToBuildFeatureRequest($bt_locator, $feature_id, $parameter_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addParameterToBuildFeature'
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $parameter_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addParameterToBuildFeatureRequest($bt_locator, $feature_id, $parameter_name, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addParameterToBuildFeature'
            );
        }
        // verify the required parameter 'feature_id' is set
        if ($feature_id === null || (is_array($feature_id) && count($feature_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_id when calling addParameterToBuildFeature'
            );
        }
        // verify the required parameter 'parameter_name' is set
        if ($parameter_name === null || (is_array($parameter_name) && count($parameter_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parameter_name when calling addParameterToBuildFeature'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features/{featureId}/parameters/{parameterName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($feature_id !== null) {
            $resourcePath = str_replace(
                '{' . 'featureId' . '}',
                ObjectSerializer::toPathValue($feature_id),
                $resourcePath
            );
        }
        // path params
        if ($parameter_name !== null) {
            $resourcePath = str_replace(
                '{' . 'parameterName' . '}',
                ObjectSerializer::toPathValue($parameter_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addParameterToBuildStep
     *
     * Add a parameter to a build step of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $step_id step_id (required)
     * @param  string $parameter_name parameter_name (required)
     * @param  string $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function addParameterToBuildStep($bt_locator, $step_id, $parameter_name, $body = null)
    {
        list($response) = $this->addParameterToBuildStepWithHttpInfo($bt_locator, $step_id, $parameter_name, $body);
        return $response;
    }

    /**
     * Operation addParameterToBuildStepWithHttpInfo
     *
     * Add a parameter to a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $parameter_name (required)
     * @param  string $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function addParameterToBuildStepWithHttpInfo($bt_locator, $step_id, $parameter_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->addParameterToBuildStepRequest($bt_locator, $step_id, $parameter_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addParameterToBuildStepAsync
     *
     * Add a parameter to a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $parameter_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addParameterToBuildStepAsync($bt_locator, $step_id, $parameter_name, $body = null)
    {
        return $this->addParameterToBuildStepAsyncWithHttpInfo($bt_locator, $step_id, $parameter_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addParameterToBuildStepAsyncWithHttpInfo
     *
     * Add a parameter to a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $parameter_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addParameterToBuildStepAsyncWithHttpInfo($bt_locator, $step_id, $parameter_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->addParameterToBuildStepRequest($bt_locator, $step_id, $parameter_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addParameterToBuildStep'
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $parameter_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addParameterToBuildStepRequest($bt_locator, $step_id, $parameter_name, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addParameterToBuildStep'
            );
        }
        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling addParameterToBuildStep'
            );
        }
        // verify the required parameter 'parameter_name' is set
        if ($parameter_name === null || (is_array($parameter_name) && count($parameter_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parameter_name when calling addParameterToBuildStep'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps/{stepId}/parameters/{parameterName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }
        // path params
        if ($parameter_name !== null) {
            $resourcePath = str_replace(
                '{' . 'parameterName' . '}',
                ObjectSerializer::toPathValue($parameter_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addSnapshotDependencyToBuildType
     *
     * Add a snapshot dependency to the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \Swagger\Client\Model\SnapshotDependency $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SnapshotDependency
     */
    public function addSnapshotDependencyToBuildType($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->addSnapshotDependencyToBuildTypeWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation addSnapshotDependencyToBuildTypeWithHttpInfo
     *
     * Add a snapshot dependency to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\SnapshotDependency $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SnapshotDependency, HTTP status code, HTTP response headers (array of strings)
     */
    public function addSnapshotDependencyToBuildTypeWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\SnapshotDependency';
        $request = $this->addSnapshotDependencyToBuildTypeRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SnapshotDependency',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addSnapshotDependencyToBuildTypeAsync
     *
     * Add a snapshot dependency to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\SnapshotDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addSnapshotDependencyToBuildTypeAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->addSnapshotDependencyToBuildTypeAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addSnapshotDependencyToBuildTypeAsyncWithHttpInfo
     *
     * Add a snapshot dependency to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\SnapshotDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addSnapshotDependencyToBuildTypeAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\SnapshotDependency';
        $request = $this->addSnapshotDependencyToBuildTypeRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addSnapshotDependencyToBuildType'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\SnapshotDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addSnapshotDependencyToBuildTypeRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addSnapshotDependencyToBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/snapshot-dependencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addTriggerToBuildType
     *
     * Add a trigger to the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \Swagger\Client\Model\Trigger $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Trigger
     */
    public function addTriggerToBuildType($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->addTriggerToBuildTypeWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation addTriggerToBuildTypeWithHttpInfo
     *
     * Add a trigger to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Trigger $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Trigger, HTTP status code, HTTP response headers (array of strings)
     */
    public function addTriggerToBuildTypeWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Trigger';
        $request = $this->addTriggerToBuildTypeRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Trigger',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addTriggerToBuildTypeAsync
     *
     * Add a trigger to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Trigger $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addTriggerToBuildTypeAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->addTriggerToBuildTypeAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addTriggerToBuildTypeAsyncWithHttpInfo
     *
     * Add a trigger to the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Trigger $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addTriggerToBuildTypeAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Trigger';
        $request = $this->addTriggerToBuildTypeRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addTriggerToBuildType'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Trigger $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addTriggerToBuildTypeRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addTriggerToBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/triggers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addVcsRootToBuildType
     *
     * Add a VCS root to the matching build.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  \Swagger\Client\Model\VcsRootEntry $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\VcsRootEntry
     */
    public function addVcsRootToBuildType($bt_locator, $body = null, $fields = null)
    {
        list($response) = $this->addVcsRootToBuildTypeWithHttpInfo($bt_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation addVcsRootToBuildTypeWithHttpInfo
     *
     * Add a VCS root to the matching build.
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\VcsRootEntry $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\VcsRootEntry, HTTP status code, HTTP response headers (array of strings)
     */
    public function addVcsRootToBuildTypeWithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\VcsRootEntry';
        $request = $this->addVcsRootToBuildTypeRequest($bt_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\VcsRootEntry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addVcsRootToBuildTypeAsync
     *
     * Add a VCS root to the matching build.
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\VcsRootEntry $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addVcsRootToBuildTypeAsync($bt_locator, $body = null, $fields = null)
    {
        return $this->addVcsRootToBuildTypeAsyncWithHttpInfo($bt_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addVcsRootToBuildTypeAsyncWithHttpInfo
     *
     * Add a VCS root to the matching build.
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\VcsRootEntry $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addVcsRootToBuildTypeAsyncWithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\VcsRootEntry';
        $request = $this->addVcsRootToBuildTypeRequest($bt_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addVcsRootToBuildType'
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\VcsRootEntry $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addVcsRootToBuildTypeRequest($bt_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling addVcsRootToBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs-root-entries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createBuildParameterOfBuildType
     *
     * Create a build parameter.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  \Swagger\Client\Model\Property $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Property
     */
    public function createBuildParameterOfBuildType($bt_locator, $body = null, $fields = null)
    {
        list($response) = $this->createBuildParameterOfBuildTypeWithHttpInfo($bt_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation createBuildParameterOfBuildTypeWithHttpInfo
     *
     * Create a build parameter.
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Property, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBuildParameterOfBuildTypeWithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Property';
        $request = $this->createBuildParameterOfBuildTypeRequest($bt_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Property',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createBuildParameterOfBuildTypeAsync
     *
     * Create a build parameter.
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBuildParameterOfBuildTypeAsync($bt_locator, $body = null, $fields = null)
    {
        return $this->createBuildParameterOfBuildTypeAsyncWithHttpInfo($bt_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBuildParameterOfBuildTypeAsyncWithHttpInfo
     *
     * Create a build parameter.
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBuildParameterOfBuildTypeAsyncWithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Property';
        $request = $this->createBuildParameterOfBuildTypeRequest($bt_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBuildParameterOfBuildType'
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createBuildParameterOfBuildTypeRequest($bt_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling createBuildParameterOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createBuildType
     *
     * Create a new build configuration.
     *
     * @param  \Swagger\Client\Model\BuildType $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\BuildType
     */
    public function createBuildType($body = null, $fields = null)
    {
        list($response) = $this->createBuildTypeWithHttpInfo($body, $fields);
        return $response;
    }

    /**
     * Operation createBuildTypeWithHttpInfo
     *
     * Create a new build configuration.
     *
     * @param  \Swagger\Client\Model\BuildType $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\BuildType, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBuildTypeWithHttpInfo($body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\BuildType';
        $request = $this->createBuildTypeRequest($body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\BuildType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createBuildTypeAsync
     *
     * Create a new build configuration.
     *
     * @param  \Swagger\Client\Model\BuildType $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBuildTypeAsync($body = null, $fields = null)
    {
        return $this->createBuildTypeAsyncWithHttpInfo($body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBuildTypeAsyncWithHttpInfo
     *
     * Create a new build configuration.
     *
     * @param  \Swagger\Client\Model\BuildType $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBuildTypeAsyncWithHttpInfo($body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\BuildType';
        $request = $this->createBuildTypeRequest($body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBuildType'
     *
     * @param  \Swagger\Client\Model\BuildType $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createBuildTypeRequest($body = null, $fields = null)
    {

        $resourcePath = '/app/rest/buildTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAgentRequirement
     *
     * Remove an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $agent_requirement_locator agent_requirement_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAgentRequirement($bt_locator, $agent_requirement_locator)
    {
        $this->deleteAgentRequirementWithHttpInfo($bt_locator, $agent_requirement_locator);
    }

    /**
     * Operation deleteAgentRequirementWithHttpInfo
     *
     * Remove an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAgentRequirementWithHttpInfo($bt_locator, $agent_requirement_locator)
    {
        $returnType = '';
        $request = $this->deleteAgentRequirementRequest($bt_locator, $agent_requirement_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAgentRequirementAsync
     *
     * Remove an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAgentRequirementAsync($bt_locator, $agent_requirement_locator)
    {
        return $this->deleteAgentRequirementAsyncWithHttpInfo($bt_locator, $agent_requirement_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAgentRequirementAsyncWithHttpInfo
     *
     * Remove an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAgentRequirementAsyncWithHttpInfo($bt_locator, $agent_requirement_locator)
    {
        $returnType = '';
        $request = $this->deleteAgentRequirementRequest($bt_locator, $agent_requirement_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAgentRequirement'
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteAgentRequirementRequest($bt_locator, $agent_requirement_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteAgentRequirement'
            );
        }
        // verify the required parameter 'agent_requirement_locator' is set
        if ($agent_requirement_locator === null || (is_array($agent_requirement_locator) && count($agent_requirement_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $agent_requirement_locator when calling deleteAgentRequirement'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/agent-requirements/{agentRequirementLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($agent_requirement_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'agentRequirementLocator' . '}',
                ObjectSerializer::toPathValue($agent_requirement_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteArtifactDependency
     *
     * Remove an artifact dependency from the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $artifact_dep_locator artifact_dep_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteArtifactDependency($bt_locator, $artifact_dep_locator)
    {
        $this->deleteArtifactDependencyWithHttpInfo($bt_locator, $artifact_dep_locator);
    }

    /**
     * Operation deleteArtifactDependencyWithHttpInfo
     *
     * Remove an artifact dependency from the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteArtifactDependencyWithHttpInfo($bt_locator, $artifact_dep_locator)
    {
        $returnType = '';
        $request = $this->deleteArtifactDependencyRequest($bt_locator, $artifact_dep_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteArtifactDependencyAsync
     *
     * Remove an artifact dependency from the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArtifactDependencyAsync($bt_locator, $artifact_dep_locator)
    {
        return $this->deleteArtifactDependencyAsyncWithHttpInfo($bt_locator, $artifact_dep_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteArtifactDependencyAsyncWithHttpInfo
     *
     * Remove an artifact dependency from the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteArtifactDependencyAsyncWithHttpInfo($bt_locator, $artifact_dep_locator)
    {
        $returnType = '';
        $request = $this->deleteArtifactDependencyRequest($bt_locator, $artifact_dep_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteArtifactDependency'
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteArtifactDependencyRequest($bt_locator, $artifact_dep_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteArtifactDependency'
            );
        }
        // verify the required parameter 'artifact_dep_locator' is set
        if ($artifact_dep_locator === null || (is_array($artifact_dep_locator) && count($artifact_dep_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $artifact_dep_locator when calling deleteArtifactDependency'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/artifact-dependencies/{artifactDepLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($artifact_dep_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'artifactDepLocator' . '}',
                ObjectSerializer::toPathValue($artifact_dep_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteBuildParameterOfBuildType
     *
     * Delete build parameter.
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteBuildParameterOfBuildType($name, $bt_locator)
    {
        $this->deleteBuildParameterOfBuildTypeWithHttpInfo($name, $bt_locator);
    }

    /**
     * Operation deleteBuildParameterOfBuildTypeWithHttpInfo
     *
     * Delete build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBuildParameterOfBuildTypeWithHttpInfo($name, $bt_locator)
    {
        $returnType = '';
        $request = $this->deleteBuildParameterOfBuildTypeRequest($name, $bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteBuildParameterOfBuildTypeAsync
     *
     * Delete build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBuildParameterOfBuildTypeAsync($name, $bt_locator)
    {
        return $this->deleteBuildParameterOfBuildTypeAsyncWithHttpInfo($name, $bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteBuildParameterOfBuildTypeAsyncWithHttpInfo
     *
     * Delete build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBuildParameterOfBuildTypeAsyncWithHttpInfo($name, $bt_locator)
    {
        $returnType = '';
        $request = $this->deleteBuildParameterOfBuildTypeRequest($name, $bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteBuildParameterOfBuildType'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteBuildParameterOfBuildTypeRequest($name, $bt_locator)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling deleteBuildParameterOfBuildType'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteBuildParameterOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteBuildParametersOfBuildType
     *
     * Delete all build parameters.
     *
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteBuildParametersOfBuildType($bt_locator)
    {
        $this->deleteBuildParametersOfBuildTypeWithHttpInfo($bt_locator);
    }

    /**
     * Operation deleteBuildParametersOfBuildTypeWithHttpInfo
     *
     * Delete all build parameters.
     *
     * @param  string $bt_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBuildParametersOfBuildTypeWithHttpInfo($bt_locator)
    {
        $returnType = '';
        $request = $this->deleteBuildParametersOfBuildTypeRequest($bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteBuildParametersOfBuildTypeAsync
     *
     * Delete all build parameters.
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBuildParametersOfBuildTypeAsync($bt_locator)
    {
        return $this->deleteBuildParametersOfBuildTypeAsyncWithHttpInfo($bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteBuildParametersOfBuildTypeAsyncWithHttpInfo
     *
     * Delete all build parameters.
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBuildParametersOfBuildTypeAsyncWithHttpInfo($bt_locator)
    {
        $returnType = '';
        $request = $this->deleteBuildParametersOfBuildTypeRequest($bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteBuildParametersOfBuildType'
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteBuildParametersOfBuildTypeRequest($bt_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteBuildParametersOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteBuildStep
     *
     * Delete a build step of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $step_id step_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteBuildStep($bt_locator, $step_id)
    {
        $this->deleteBuildStepWithHttpInfo($bt_locator, $step_id);
    }

    /**
     * Operation deleteBuildStepWithHttpInfo
     *
     * Delete a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBuildStepWithHttpInfo($bt_locator, $step_id)
    {
        $returnType = '';
        $request = $this->deleteBuildStepRequest($bt_locator, $step_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteBuildStepAsync
     *
     * Delete a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBuildStepAsync($bt_locator, $step_id)
    {
        return $this->deleteBuildStepAsyncWithHttpInfo($bt_locator, $step_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteBuildStepAsyncWithHttpInfo
     *
     * Delete a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBuildStepAsyncWithHttpInfo($bt_locator, $step_id)
    {
        $returnType = '';
        $request = $this->deleteBuildStepRequest($bt_locator, $step_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteBuildStep'
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteBuildStepRequest($bt_locator, $step_id)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteBuildStep'
            );
        }
        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling deleteBuildStep'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps/{stepId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteBuildStepParameters
     *
     * Update a parameter of a build step of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $step_id step_id (required)
     * @param  \Swagger\Client\Model\Properties $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Properties
     */
    public function deleteBuildStepParameters($bt_locator, $step_id, $body = null, $fields = null)
    {
        list($response) = $this->deleteBuildStepParametersWithHttpInfo($bt_locator, $step_id, $body, $fields);
        return $response;
    }

    /**
     * Operation deleteBuildStepParametersWithHttpInfo
     *
     * Update a parameter of a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  \Swagger\Client\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Properties, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBuildStepParametersWithHttpInfo($bt_locator, $step_id, $body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Properties';
        $request = $this->deleteBuildStepParametersRequest($bt_locator, $step_id, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Properties',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteBuildStepParametersAsync
     *
     * Update a parameter of a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  \Swagger\Client\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBuildStepParametersAsync($bt_locator, $step_id, $body = null, $fields = null)
    {
        return $this->deleteBuildStepParametersAsyncWithHttpInfo($bt_locator, $step_id, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteBuildStepParametersAsyncWithHttpInfo
     *
     * Update a parameter of a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  \Swagger\Client\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBuildStepParametersAsyncWithHttpInfo($bt_locator, $step_id, $body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Properties';
        $request = $this->deleteBuildStepParametersRequest($bt_locator, $step_id, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteBuildStepParameters'
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  \Swagger\Client\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteBuildStepParametersRequest($bt_locator, $step_id, $body = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteBuildStepParameters'
            );
        }
        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling deleteBuildStepParameters'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps/{stepId}/parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteBuildType
     *
     * Delete build configuration matching the locator.
     *
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteBuildType($bt_locator)
    {
        $this->deleteBuildTypeWithHttpInfo($bt_locator);
    }

    /**
     * Operation deleteBuildTypeWithHttpInfo
     *
     * Delete build configuration matching the locator.
     *
     * @param  string $bt_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBuildTypeWithHttpInfo($bt_locator)
    {
        $returnType = '';
        $request = $this->deleteBuildTypeRequest($bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteBuildTypeAsync
     *
     * Delete build configuration matching the locator.
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBuildTypeAsync($bt_locator)
    {
        return $this->deleteBuildTypeAsyncWithHttpInfo($bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteBuildTypeAsyncWithHttpInfo
     *
     * Delete build configuration matching the locator.
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBuildTypeAsyncWithHttpInfo($bt_locator)
    {
        $returnType = '';
        $request = $this->deleteBuildTypeRequest($bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteBuildType'
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteBuildTypeRequest($bt_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFeatureOfBuildType
     *
     * Remove a build feature of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $feature_id feature_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteFeatureOfBuildType($bt_locator, $feature_id)
    {
        $this->deleteFeatureOfBuildTypeWithHttpInfo($bt_locator, $feature_id);
    }

    /**
     * Operation deleteFeatureOfBuildTypeWithHttpInfo
     *
     * Remove a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFeatureOfBuildTypeWithHttpInfo($bt_locator, $feature_id)
    {
        $returnType = '';
        $request = $this->deleteFeatureOfBuildTypeRequest($bt_locator, $feature_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFeatureOfBuildTypeAsync
     *
     * Remove a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFeatureOfBuildTypeAsync($bt_locator, $feature_id)
    {
        return $this->deleteFeatureOfBuildTypeAsyncWithHttpInfo($bt_locator, $feature_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFeatureOfBuildTypeAsyncWithHttpInfo
     *
     * Remove a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFeatureOfBuildTypeAsyncWithHttpInfo($bt_locator, $feature_id)
    {
        $returnType = '';
        $request = $this->deleteFeatureOfBuildTypeRequest($bt_locator, $feature_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFeatureOfBuildType'
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteFeatureOfBuildTypeRequest($bt_locator, $feature_id)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteFeatureOfBuildType'
            );
        }
        // verify the required parameter 'feature_id' is set
        if ($feature_id === null || (is_array($feature_id) && count($feature_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_id when calling deleteFeatureOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features/{featureId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($feature_id !== null) {
            $resourcePath = str_replace(
                '{' . 'featureId' . '}',
                ObjectSerializer::toPathValue($feature_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSnapshotDependency
     *
     * Delete a snapshot dependency of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $snapshot_dep_locator snapshot_dep_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteSnapshotDependency($bt_locator, $snapshot_dep_locator)
    {
        $this->deleteSnapshotDependencyWithHttpInfo($bt_locator, $snapshot_dep_locator);
    }

    /**
     * Operation deleteSnapshotDependencyWithHttpInfo
     *
     * Delete a snapshot dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteSnapshotDependencyWithHttpInfo($bt_locator, $snapshot_dep_locator)
    {
        $returnType = '';
        $request = $this->deleteSnapshotDependencyRequest($bt_locator, $snapshot_dep_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteSnapshotDependencyAsync
     *
     * Delete a snapshot dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSnapshotDependencyAsync($bt_locator, $snapshot_dep_locator)
    {
        return $this->deleteSnapshotDependencyAsyncWithHttpInfo($bt_locator, $snapshot_dep_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSnapshotDependencyAsyncWithHttpInfo
     *
     * Delete a snapshot dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSnapshotDependencyAsyncWithHttpInfo($bt_locator, $snapshot_dep_locator)
    {
        $returnType = '';
        $request = $this->deleteSnapshotDependencyRequest($bt_locator, $snapshot_dep_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSnapshotDependency'
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteSnapshotDependencyRequest($bt_locator, $snapshot_dep_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteSnapshotDependency'
            );
        }
        // verify the required parameter 'snapshot_dep_locator' is set
        if ($snapshot_dep_locator === null || (is_array($snapshot_dep_locator) && count($snapshot_dep_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $snapshot_dep_locator when calling deleteSnapshotDependency'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/snapshot-dependencies/{snapshotDepLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($snapshot_dep_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'snapshotDepLocator' . '}',
                ObjectSerializer::toPathValue($snapshot_dep_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTrigger
     *
     * Delete a trigger of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $trigger_locator trigger_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTrigger($bt_locator, $trigger_locator)
    {
        $this->deleteTriggerWithHttpInfo($bt_locator, $trigger_locator);
    }

    /**
     * Operation deleteTriggerWithHttpInfo
     *
     * Delete a trigger of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTriggerWithHttpInfo($bt_locator, $trigger_locator)
    {
        $returnType = '';
        $request = $this->deleteTriggerRequest($bt_locator, $trigger_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTriggerAsync
     *
     * Delete a trigger of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTriggerAsync($bt_locator, $trigger_locator)
    {
        return $this->deleteTriggerAsyncWithHttpInfo($bt_locator, $trigger_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTriggerAsyncWithHttpInfo
     *
     * Delete a trigger of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTriggerAsyncWithHttpInfo($bt_locator, $trigger_locator)
    {
        $returnType = '';
        $request = $this->deleteTriggerRequest($bt_locator, $trigger_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTrigger'
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTriggerRequest($bt_locator, $trigger_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteTrigger'
            );
        }
        // verify the required parameter 'trigger_locator' is set
        if ($trigger_locator === null || (is_array($trigger_locator) && count($trigger_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trigger_locator when calling deleteTrigger'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/triggers/{triggerLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($trigger_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'triggerLocator' . '}',
                ObjectSerializer::toPathValue($trigger_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteVcsRootOfBuildType
     *
     * Remove a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $vcs_root_locator vcs_root_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteVcsRootOfBuildType($bt_locator, $vcs_root_locator)
    {
        $this->deleteVcsRootOfBuildTypeWithHttpInfo($bt_locator, $vcs_root_locator);
    }

    /**
     * Operation deleteVcsRootOfBuildTypeWithHttpInfo
     *
     * Remove a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteVcsRootOfBuildTypeWithHttpInfo($bt_locator, $vcs_root_locator)
    {
        $returnType = '';
        $request = $this->deleteVcsRootOfBuildTypeRequest($bt_locator, $vcs_root_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteVcsRootOfBuildTypeAsync
     *
     * Remove a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVcsRootOfBuildTypeAsync($bt_locator, $vcs_root_locator)
    {
        return $this->deleteVcsRootOfBuildTypeAsyncWithHttpInfo($bt_locator, $vcs_root_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteVcsRootOfBuildTypeAsyncWithHttpInfo
     *
     * Remove a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteVcsRootOfBuildTypeAsyncWithHttpInfo($bt_locator, $vcs_root_locator)
    {
        $returnType = '';
        $request = $this->deleteVcsRootOfBuildTypeRequest($bt_locator, $vcs_root_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteVcsRootOfBuildType'
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteVcsRootOfBuildTypeRequest($bt_locator, $vcs_root_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling deleteVcsRootOfBuildType'
            );
        }
        // verify the required parameter 'vcs_root_locator' is set
        if ($vcs_root_locator === null || (is_array($vcs_root_locator) && count($vcs_root_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vcs_root_locator when calling deleteVcsRootOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs-root-entries/{vcsRootLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($vcs_root_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'vcsRootLocator' . '}',
                ObjectSerializer::toPathValue($vcs_root_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadFileOfBuildType
     *
     * Download specific file.
     *
     * @param  string $path path (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  bool $resolve_parameters resolve_parameters (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function downloadFileOfBuildType($path, $bt_locator, $resolve_parameters = null)
    {
        $this->downloadFileOfBuildTypeWithHttpInfo($path, $bt_locator, $resolve_parameters);
    }

    /**
     * Operation downloadFileOfBuildTypeWithHttpInfo
     *
     * Download specific file.
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadFileOfBuildTypeWithHttpInfo($path, $bt_locator, $resolve_parameters = null)
    {
        $returnType = '';
        $request = $this->downloadFileOfBuildTypeRequest($path, $bt_locator, $resolve_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation downloadFileOfBuildTypeAsync
     *
     * Download specific file.
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadFileOfBuildTypeAsync($path, $bt_locator, $resolve_parameters = null)
    {
        return $this->downloadFileOfBuildTypeAsyncWithHttpInfo($path, $bt_locator, $resolve_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadFileOfBuildTypeAsyncWithHttpInfo
     *
     * Download specific file.
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadFileOfBuildTypeAsyncWithHttpInfo($path, $bt_locator, $resolve_parameters = null)
    {
        $returnType = '';
        $request = $this->downloadFileOfBuildTypeRequest($path, $bt_locator, $resolve_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadFileOfBuildType'
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function downloadFileOfBuildTypeRequest($path, $bt_locator, $resolve_parameters = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling downloadFileOfBuildType'
            );
        }
        if (!preg_match("/(\/.*)?/", $path)) {
            throw new \InvalidArgumentException("invalid value for \"path\" when calling BuildTypeApi.downloadFileOfBuildType, must conform to the pattern /(\/.*)?/.");
        }

        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling downloadFileOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs/files/latest/files{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($resolve_parameters !== null) {
            $queryParams['resolveParameters'] = ObjectSerializer::toQueryValue($resolve_parameters);
        }

        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAgentRequirement
     *
     * Get an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $agent_requirement_locator agent_requirement_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\AgentRequirement
     */
    public function getAgentRequirement($bt_locator, $agent_requirement_locator, $fields = null)
    {
        list($response) = $this->getAgentRequirementWithHttpInfo($bt_locator, $agent_requirement_locator, $fields);
        return $response;
    }

    /**
     * Operation getAgentRequirementWithHttpInfo
     *
     * Get an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\AgentRequirement, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAgentRequirementWithHttpInfo($bt_locator, $agent_requirement_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\AgentRequirement';
        $request = $this->getAgentRequirementRequest($bt_locator, $agent_requirement_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AgentRequirement',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAgentRequirementAsync
     *
     * Get an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgentRequirementAsync($bt_locator, $agent_requirement_locator, $fields = null)
    {
        return $this->getAgentRequirementAsyncWithHttpInfo($bt_locator, $agent_requirement_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAgentRequirementAsyncWithHttpInfo
     *
     * Get an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgentRequirementAsyncWithHttpInfo($bt_locator, $agent_requirement_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\AgentRequirement';
        $request = $this->getAgentRequirementRequest($bt_locator, $agent_requirement_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAgentRequirement'
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAgentRequirementRequest($bt_locator, $agent_requirement_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getAgentRequirement'
            );
        }
        // verify the required parameter 'agent_requirement_locator' is set
        if ($agent_requirement_locator === null || (is_array($agent_requirement_locator) && count($agent_requirement_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $agent_requirement_locator when calling getAgentRequirement'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/agent-requirements/{agentRequirementLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($agent_requirement_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'agentRequirementLocator' . '}',
                ObjectSerializer::toPathValue($agent_requirement_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAgentRequirementParameter
     *
     * Get a setting of an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $agent_requirement_locator agent_requirement_locator (required)
     * @param  string $field_name field_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getAgentRequirementParameter($bt_locator, $agent_requirement_locator, $field_name)
    {
        list($response) = $this->getAgentRequirementParameterWithHttpInfo($bt_locator, $agent_requirement_locator, $field_name);
        return $response;
    }

    /**
     * Operation getAgentRequirementParameterWithHttpInfo
     *
     * Get a setting of an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAgentRequirementParameterWithHttpInfo($bt_locator, $agent_requirement_locator, $field_name)
    {
        $returnType = 'string';
        $request = $this->getAgentRequirementParameterRequest($bt_locator, $agent_requirement_locator, $field_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAgentRequirementParameterAsync
     *
     * Get a setting of an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgentRequirementParameterAsync($bt_locator, $agent_requirement_locator, $field_name)
    {
        return $this->getAgentRequirementParameterAsyncWithHttpInfo($bt_locator, $agent_requirement_locator, $field_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAgentRequirementParameterAsyncWithHttpInfo
     *
     * Get a setting of an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgentRequirementParameterAsyncWithHttpInfo($bt_locator, $agent_requirement_locator, $field_name)
    {
        $returnType = 'string';
        $request = $this->getAgentRequirementParameterRequest($bt_locator, $agent_requirement_locator, $field_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAgentRequirementParameter'
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAgentRequirementParameterRequest($bt_locator, $agent_requirement_locator, $field_name)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getAgentRequirementParameter'
            );
        }
        // verify the required parameter 'agent_requirement_locator' is set
        if ($agent_requirement_locator === null || (is_array($agent_requirement_locator) && count($agent_requirement_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $agent_requirement_locator when calling getAgentRequirementParameter'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null || (is_array($field_name) && count($field_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling getAgentRequirementParameter'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/agent-requirements/{agentRequirementLocator}/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($agent_requirement_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'agentRequirementLocator' . '}',
                ObjectSerializer::toPathValue($agent_requirement_locator),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAliases
     *
     * Get external IDs of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $field field (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Items
     */
    public function getAliases($bt_locator, $field = null)
    {
        list($response) = $this->getAliasesWithHttpInfo($bt_locator, $field);
        return $response;
    }

    /**
     * Operation getAliasesWithHttpInfo
     *
     * Get external IDs of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $field (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Items, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAliasesWithHttpInfo($bt_locator, $field = null)
    {
        $returnType = '\Swagger\Client\Model\Items';
        $request = $this->getAliasesRequest($bt_locator, $field);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Items',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAliasesAsync
     *
     * Get external IDs of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $field (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAliasesAsync($bt_locator, $field = null)
    {
        return $this->getAliasesAsyncWithHttpInfo($bt_locator, $field)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAliasesAsyncWithHttpInfo
     *
     * Get external IDs of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $field (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAliasesAsyncWithHttpInfo($bt_locator, $field = null)
    {
        $returnType = '\Swagger\Client\Model\Items';
        $request = $this->getAliasesRequest($bt_locator, $field);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAliases'
     *
     * @param  string $bt_locator (required)
     * @param  string $field (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAliasesRequest($bt_locator, $field = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getAliases'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/aliases';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($field !== null) {
            $queryParams['field'] = ObjectSerializer::toQueryValue($field);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllAgentRequirements
     *
     * Get all agent requirements of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\AgentRequirements
     */
    public function getAllAgentRequirements($bt_locator, $fields = null)
    {
        list($response) = $this->getAllAgentRequirementsWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getAllAgentRequirementsWithHttpInfo
     *
     * Get all agent requirements of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\AgentRequirements, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllAgentRequirementsWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\AgentRequirements';
        $request = $this->getAllAgentRequirementsRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AgentRequirements',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllAgentRequirementsAsync
     *
     * Get all agent requirements of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllAgentRequirementsAsync($bt_locator, $fields = null)
    {
        return $this->getAllAgentRequirementsAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllAgentRequirementsAsyncWithHttpInfo
     *
     * Get all agent requirements of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllAgentRequirementsAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\AgentRequirements';
        $request = $this->getAllAgentRequirementsRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllAgentRequirements'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllAgentRequirementsRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getAllAgentRequirements'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/agent-requirements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllArtifactDependencies
     *
     * Get all artifact dependencies of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ArtifactDependencies
     */
    public function getAllArtifactDependencies($bt_locator, $fields = null)
    {
        list($response) = $this->getAllArtifactDependenciesWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getAllArtifactDependenciesWithHttpInfo
     *
     * Get all artifact dependencies of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ArtifactDependencies, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllArtifactDependenciesWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\ArtifactDependencies';
        $request = $this->getAllArtifactDependenciesRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ArtifactDependencies',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllArtifactDependenciesAsync
     *
     * Get all artifact dependencies of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllArtifactDependenciesAsync($bt_locator, $fields = null)
    {
        return $this->getAllArtifactDependenciesAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllArtifactDependenciesAsyncWithHttpInfo
     *
     * Get all artifact dependencies of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllArtifactDependenciesAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\ArtifactDependencies';
        $request = $this->getAllArtifactDependenciesRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllArtifactDependencies'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllArtifactDependenciesRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getAllArtifactDependencies'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/artifact-dependencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllBranchesOfBuildType
     *
     * Get all branches of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $locator locator (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Branches
     */
    public function getAllBranchesOfBuildType($bt_locator, $locator = null, $fields = null)
    {
        list($response) = $this->getAllBranchesOfBuildTypeWithHttpInfo($bt_locator, $locator, $fields);
        return $response;
    }

    /**
     * Operation getAllBranchesOfBuildTypeWithHttpInfo
     *
     * Get all branches of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Branches, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllBranchesOfBuildTypeWithHttpInfo($bt_locator, $locator = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Branches';
        $request = $this->getAllBranchesOfBuildTypeRequest($bt_locator, $locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Branches',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllBranchesOfBuildTypeAsync
     *
     * Get all branches of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllBranchesOfBuildTypeAsync($bt_locator, $locator = null, $fields = null)
    {
        return $this->getAllBranchesOfBuildTypeAsyncWithHttpInfo($bt_locator, $locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllBranchesOfBuildTypeAsyncWithHttpInfo
     *
     * Get all branches of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllBranchesOfBuildTypeAsyncWithHttpInfo($bt_locator, $locator = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Branches';
        $request = $this->getAllBranchesOfBuildTypeRequest($bt_locator, $locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllBranchesOfBuildType'
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllBranchesOfBuildTypeRequest($bt_locator, $locator = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getAllBranchesOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/branches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllBuildFeatureParameters
     *
     * Get all parameters of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $feature_id feature_id (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Properties
     */
    public function getAllBuildFeatureParameters($bt_locator, $feature_id, $fields = null)
    {
        list($response) = $this->getAllBuildFeatureParametersWithHttpInfo($bt_locator, $feature_id, $fields);
        return $response;
    }

    /**
     * Operation getAllBuildFeatureParametersWithHttpInfo
     *
     * Get all parameters of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Properties, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllBuildFeatureParametersWithHttpInfo($bt_locator, $feature_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Properties';
        $request = $this->getAllBuildFeatureParametersRequest($bt_locator, $feature_id, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Properties',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllBuildFeatureParametersAsync
     *
     * Get all parameters of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllBuildFeatureParametersAsync($bt_locator, $feature_id, $fields = null)
    {
        return $this->getAllBuildFeatureParametersAsyncWithHttpInfo($bt_locator, $feature_id, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllBuildFeatureParametersAsyncWithHttpInfo
     *
     * Get all parameters of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllBuildFeatureParametersAsyncWithHttpInfo($bt_locator, $feature_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Properties';
        $request = $this->getAllBuildFeatureParametersRequest($bt_locator, $feature_id, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllBuildFeatureParameters'
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllBuildFeatureParametersRequest($bt_locator, $feature_id, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getAllBuildFeatureParameters'
            );
        }
        // verify the required parameter 'feature_id' is set
        if ($feature_id === null || (is_array($feature_id) && count($feature_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_id when calling getAllBuildFeatureParameters'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features/{featureId}/parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($feature_id !== null) {
            $resourcePath = str_replace(
                '{' . 'featureId' . '}',
                ObjectSerializer::toPathValue($feature_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllBuildFeatures
     *
     * Get all build features of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Features
     */
    public function getAllBuildFeatures($bt_locator, $fields = null)
    {
        list($response) = $this->getAllBuildFeaturesWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getAllBuildFeaturesWithHttpInfo
     *
     * Get all build features of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Features, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllBuildFeaturesWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Features';
        $request = $this->getAllBuildFeaturesRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Features',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllBuildFeaturesAsync
     *
     * Get all build features of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllBuildFeaturesAsync($bt_locator, $fields = null)
    {
        return $this->getAllBuildFeaturesAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllBuildFeaturesAsyncWithHttpInfo
     *
     * Get all build features of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllBuildFeaturesAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Features';
        $request = $this->getAllBuildFeaturesRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllBuildFeatures'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllBuildFeaturesRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getAllBuildFeatures'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllBuildStepParameters
     *
     * Get all parameters of a build step of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $step_id step_id (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Properties
     */
    public function getAllBuildStepParameters($bt_locator, $step_id, $fields = null)
    {
        list($response) = $this->getAllBuildStepParametersWithHttpInfo($bt_locator, $step_id, $fields);
        return $response;
    }

    /**
     * Operation getAllBuildStepParametersWithHttpInfo
     *
     * Get all parameters of a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Properties, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllBuildStepParametersWithHttpInfo($bt_locator, $step_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Properties';
        $request = $this->getAllBuildStepParametersRequest($bt_locator, $step_id, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Properties',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllBuildStepParametersAsync
     *
     * Get all parameters of a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllBuildStepParametersAsync($bt_locator, $step_id, $fields = null)
    {
        return $this->getAllBuildStepParametersAsyncWithHttpInfo($bt_locator, $step_id, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllBuildStepParametersAsyncWithHttpInfo
     *
     * Get all parameters of a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllBuildStepParametersAsyncWithHttpInfo($bt_locator, $step_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Properties';
        $request = $this->getAllBuildStepParametersRequest($bt_locator, $step_id, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllBuildStepParameters'
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllBuildStepParametersRequest($bt_locator, $step_id, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getAllBuildStepParameters'
            );
        }
        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling getAllBuildStepParameters'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps/{stepId}/parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllBuildSteps
     *
     * Get all build steps of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Steps
     */
    public function getAllBuildSteps($bt_locator, $fields = null)
    {
        list($response) = $this->getAllBuildStepsWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getAllBuildStepsWithHttpInfo
     *
     * Get all build steps of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Steps, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllBuildStepsWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Steps';
        $request = $this->getAllBuildStepsRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Steps',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllBuildStepsAsync
     *
     * Get all build steps of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllBuildStepsAsync($bt_locator, $fields = null)
    {
        return $this->getAllBuildStepsAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllBuildStepsAsyncWithHttpInfo
     *
     * Get all build steps of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllBuildStepsAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Steps';
        $request = $this->getAllBuildStepsRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllBuildSteps'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllBuildStepsRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getAllBuildSteps'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllBuildTemplates
     *
     * Get all build templates of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\BuildTypes
     */
    public function getAllBuildTemplates($bt_locator, $fields = null)
    {
        list($response) = $this->getAllBuildTemplatesWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getAllBuildTemplatesWithHttpInfo
     *
     * Get all build templates of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\BuildTypes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllBuildTemplatesWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\BuildTypes';
        $request = $this->getAllBuildTemplatesRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\BuildTypes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllBuildTemplatesAsync
     *
     * Get all build templates of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllBuildTemplatesAsync($bt_locator, $fields = null)
    {
        return $this->getAllBuildTemplatesAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllBuildTemplatesAsyncWithHttpInfo
     *
     * Get all build templates of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllBuildTemplatesAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\BuildTypes';
        $request = $this->getAllBuildTemplatesRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllBuildTemplates'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllBuildTemplatesRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getAllBuildTemplates'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllBuildTypes
     *
     * Get all build configurations.
     *
     * @param  string $locator locator (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\BuildTypes
     */
    public function getAllBuildTypes($locator = null, $fields = null)
    {
        list($response) = $this->getAllBuildTypesWithHttpInfo($locator, $fields);
        return $response;
    }

    /**
     * Operation getAllBuildTypesWithHttpInfo
     *
     * Get all build configurations.
     *
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\BuildTypes, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllBuildTypesWithHttpInfo($locator = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\BuildTypes';
        $request = $this->getAllBuildTypesRequest($locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\BuildTypes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllBuildTypesAsync
     *
     * Get all build configurations.
     *
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllBuildTypesAsync($locator = null, $fields = null)
    {
        return $this->getAllBuildTypesAsyncWithHttpInfo($locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllBuildTypesAsyncWithHttpInfo
     *
     * Get all build configurations.
     *
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllBuildTypesAsyncWithHttpInfo($locator = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\BuildTypes';
        $request = $this->getAllBuildTypesRequest($locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllBuildTypes'
     *
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllBuildTypesRequest($locator = null, $fields = null)
    {

        $resourcePath = '/app/rest/buildTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllInvestigationsOfBuildType
     *
     * Get all investigations of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Investigations
     */
    public function getAllInvestigationsOfBuildType($bt_locator, $fields = null)
    {
        list($response) = $this->getAllInvestigationsOfBuildTypeWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getAllInvestigationsOfBuildTypeWithHttpInfo
     *
     * Get all investigations of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Investigations, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllInvestigationsOfBuildTypeWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Investigations';
        $request = $this->getAllInvestigationsOfBuildTypeRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Investigations',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllInvestigationsOfBuildTypeAsync
     *
     * Get all investigations of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllInvestigationsOfBuildTypeAsync($bt_locator, $fields = null)
    {
        return $this->getAllInvestigationsOfBuildTypeAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllInvestigationsOfBuildTypeAsyncWithHttpInfo
     *
     * Get all investigations of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllInvestigationsOfBuildTypeAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Investigations';
        $request = $this->getAllInvestigationsOfBuildTypeRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllInvestigationsOfBuildType'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllInvestigationsOfBuildTypeRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getAllInvestigationsOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/investigations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllSnapshotDependencies
     *
     * Get all snapshot dependencies of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SnapshotDependencies
     */
    public function getAllSnapshotDependencies($bt_locator, $fields = null)
    {
        list($response) = $this->getAllSnapshotDependenciesWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getAllSnapshotDependenciesWithHttpInfo
     *
     * Get all snapshot dependencies of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SnapshotDependencies, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllSnapshotDependenciesWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\SnapshotDependencies';
        $request = $this->getAllSnapshotDependenciesRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SnapshotDependencies',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllSnapshotDependenciesAsync
     *
     * Get all snapshot dependencies of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllSnapshotDependenciesAsync($bt_locator, $fields = null)
    {
        return $this->getAllSnapshotDependenciesAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllSnapshotDependenciesAsyncWithHttpInfo
     *
     * Get all snapshot dependencies of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllSnapshotDependenciesAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\SnapshotDependencies';
        $request = $this->getAllSnapshotDependenciesRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllSnapshotDependencies'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllSnapshotDependenciesRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getAllSnapshotDependencies'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/snapshot-dependencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllTriggers
     *
     * Get all triggers of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Triggers
     */
    public function getAllTriggers($bt_locator, $fields = null)
    {
        list($response) = $this->getAllTriggersWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getAllTriggersWithHttpInfo
     *
     * Get all triggers of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Triggers, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllTriggersWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Triggers';
        $request = $this->getAllTriggersRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Triggers',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllTriggersAsync
     *
     * Get all triggers of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllTriggersAsync($bt_locator, $fields = null)
    {
        return $this->getAllTriggersAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllTriggersAsyncWithHttpInfo
     *
     * Get all triggers of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllTriggersAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Triggers';
        $request = $this->getAllTriggersRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllTriggers'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllTriggersRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getAllTriggers'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/triggers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllVcsRootsOfBuildType
     *
     * Get all VCS roots of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\VcsRootEntries
     */
    public function getAllVcsRootsOfBuildType($bt_locator, $fields = null)
    {
        list($response) = $this->getAllVcsRootsOfBuildTypeWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getAllVcsRootsOfBuildTypeWithHttpInfo
     *
     * Get all VCS roots of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\VcsRootEntries, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllVcsRootsOfBuildTypeWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\VcsRootEntries';
        $request = $this->getAllVcsRootsOfBuildTypeRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\VcsRootEntries',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllVcsRootsOfBuildTypeAsync
     *
     * Get all VCS roots of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllVcsRootsOfBuildTypeAsync($bt_locator, $fields = null)
    {
        return $this->getAllVcsRootsOfBuildTypeAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllVcsRootsOfBuildTypeAsyncWithHttpInfo
     *
     * Get all VCS roots of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllVcsRootsOfBuildTypeAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\VcsRootEntries';
        $request = $this->getAllVcsRootsOfBuildTypeRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllVcsRootsOfBuildType'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllVcsRootsOfBuildTypeRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getAllVcsRootsOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs-root-entries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArtifactDependency
     *
     * Get an artifact dependency of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $artifact_dep_locator artifact_dep_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ArtifactDependency
     */
    public function getArtifactDependency($bt_locator, $artifact_dep_locator, $fields = null)
    {
        list($response) = $this->getArtifactDependencyWithHttpInfo($bt_locator, $artifact_dep_locator, $fields);
        return $response;
    }

    /**
     * Operation getArtifactDependencyWithHttpInfo
     *
     * Get an artifact dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ArtifactDependency, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArtifactDependencyWithHttpInfo($bt_locator, $artifact_dep_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\ArtifactDependency';
        $request = $this->getArtifactDependencyRequest($bt_locator, $artifact_dep_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ArtifactDependency',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArtifactDependencyAsync
     *
     * Get an artifact dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArtifactDependencyAsync($bt_locator, $artifact_dep_locator, $fields = null)
    {
        return $this->getArtifactDependencyAsyncWithHttpInfo($bt_locator, $artifact_dep_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArtifactDependencyAsyncWithHttpInfo
     *
     * Get an artifact dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArtifactDependencyAsyncWithHttpInfo($bt_locator, $artifact_dep_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\ArtifactDependency';
        $request = $this->getArtifactDependencyRequest($bt_locator, $artifact_dep_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArtifactDependency'
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArtifactDependencyRequest($bt_locator, $artifact_dep_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getArtifactDependency'
            );
        }
        // verify the required parameter 'artifact_dep_locator' is set
        if ($artifact_dep_locator === null || (is_array($artifact_dep_locator) && count($artifact_dep_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $artifact_dep_locator when calling getArtifactDependency'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/artifact-dependencies/{artifactDepLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($artifact_dep_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'artifactDepLocator' . '}',
                ObjectSerializer::toPathValue($artifact_dep_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getArtifactDependencyParameter
     *
     * Get a parameter of an artifact dependency of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $artifact_dep_locator artifact_dep_locator (required)
     * @param  string $field_name field_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getArtifactDependencyParameter($bt_locator, $artifact_dep_locator, $field_name)
    {
        list($response) = $this->getArtifactDependencyParameterWithHttpInfo($bt_locator, $artifact_dep_locator, $field_name);
        return $response;
    }

    /**
     * Operation getArtifactDependencyParameterWithHttpInfo
     *
     * Get a parameter of an artifact dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getArtifactDependencyParameterWithHttpInfo($bt_locator, $artifact_dep_locator, $field_name)
    {
        $returnType = 'string';
        $request = $this->getArtifactDependencyParameterRequest($bt_locator, $artifact_dep_locator, $field_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getArtifactDependencyParameterAsync
     *
     * Get a parameter of an artifact dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArtifactDependencyParameterAsync($bt_locator, $artifact_dep_locator, $field_name)
    {
        return $this->getArtifactDependencyParameterAsyncWithHttpInfo($bt_locator, $artifact_dep_locator, $field_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getArtifactDependencyParameterAsyncWithHttpInfo
     *
     * Get a parameter of an artifact dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getArtifactDependencyParameterAsyncWithHttpInfo($bt_locator, $artifact_dep_locator, $field_name)
    {
        $returnType = 'string';
        $request = $this->getArtifactDependencyParameterRequest($bt_locator, $artifact_dep_locator, $field_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getArtifactDependencyParameter'
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getArtifactDependencyParameterRequest($bt_locator, $artifact_dep_locator, $field_name)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getArtifactDependencyParameter'
            );
        }
        // verify the required parameter 'artifact_dep_locator' is set
        if ($artifact_dep_locator === null || (is_array($artifact_dep_locator) && count($artifact_dep_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $artifact_dep_locator when calling getArtifactDependencyParameter'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null || (is_array($field_name) && count($field_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling getArtifactDependencyParameter'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/artifact-dependencies/{artifactDepLocator}/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($artifact_dep_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'artifactDepLocator' . '}',
                ObjectSerializer::toPathValue($artifact_dep_locator),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildFeature
     *
     * Get a build feature of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $feature_id feature_id (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Feature
     */
    public function getBuildFeature($bt_locator, $feature_id, $fields = null)
    {
        list($response) = $this->getBuildFeatureWithHttpInfo($bt_locator, $feature_id, $fields);
        return $response;
    }

    /**
     * Operation getBuildFeatureWithHttpInfo
     *
     * Get a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Feature, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildFeatureWithHttpInfo($bt_locator, $feature_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Feature';
        $request = $this->getBuildFeatureRequest($bt_locator, $feature_id, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Feature',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildFeatureAsync
     *
     * Get a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildFeatureAsync($bt_locator, $feature_id, $fields = null)
    {
        return $this->getBuildFeatureAsyncWithHttpInfo($bt_locator, $feature_id, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildFeatureAsyncWithHttpInfo
     *
     * Get a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildFeatureAsyncWithHttpInfo($bt_locator, $feature_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Feature';
        $request = $this->getBuildFeatureRequest($bt_locator, $feature_id, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildFeature'
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildFeatureRequest($bt_locator, $feature_id, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getBuildFeature'
            );
        }
        // verify the required parameter 'feature_id' is set
        if ($feature_id === null || (is_array($feature_id) && count($feature_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_id when calling getBuildFeature'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features/{featureId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($feature_id !== null) {
            $resourcePath = str_replace(
                '{' . 'featureId' . '}',
                ObjectSerializer::toPathValue($feature_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildFeatureParameter
     *
     * Get a parameter of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $feature_id feature_id (required)
     * @param  string $parameter_name parameter_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getBuildFeatureParameter($bt_locator, $feature_id, $parameter_name)
    {
        list($response) = $this->getBuildFeatureParameterWithHttpInfo($bt_locator, $feature_id, $parameter_name);
        return $response;
    }

    /**
     * Operation getBuildFeatureParameterWithHttpInfo
     *
     * Get a parameter of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $parameter_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildFeatureParameterWithHttpInfo($bt_locator, $feature_id, $parameter_name)
    {
        $returnType = 'string';
        $request = $this->getBuildFeatureParameterRequest($bt_locator, $feature_id, $parameter_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildFeatureParameterAsync
     *
     * Get a parameter of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $parameter_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildFeatureParameterAsync($bt_locator, $feature_id, $parameter_name)
    {
        return $this->getBuildFeatureParameterAsyncWithHttpInfo($bt_locator, $feature_id, $parameter_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildFeatureParameterAsyncWithHttpInfo
     *
     * Get a parameter of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $parameter_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildFeatureParameterAsyncWithHttpInfo($bt_locator, $feature_id, $parameter_name)
    {
        $returnType = 'string';
        $request = $this->getBuildFeatureParameterRequest($bt_locator, $feature_id, $parameter_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildFeatureParameter'
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $parameter_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildFeatureParameterRequest($bt_locator, $feature_id, $parameter_name)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getBuildFeatureParameter'
            );
        }
        // verify the required parameter 'feature_id' is set
        if ($feature_id === null || (is_array($feature_id) && count($feature_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_id when calling getBuildFeatureParameter'
            );
        }
        // verify the required parameter 'parameter_name' is set
        if ($parameter_name === null || (is_array($parameter_name) && count($parameter_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parameter_name when calling getBuildFeatureParameter'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features/{featureId}/parameters/{parameterName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($feature_id !== null) {
            $resourcePath = str_replace(
                '{' . 'featureId' . '}',
                ObjectSerializer::toPathValue($feature_id),
                $resourcePath
            );
        }
        // path params
        if ($parameter_name !== null) {
            $resourcePath = str_replace(
                '{' . 'parameterName' . '}',
                ObjectSerializer::toPathValue($parameter_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildFeatureSetting
     *
     * Get the setting of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $feature_id feature_id (required)
     * @param  string $name name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getBuildFeatureSetting($bt_locator, $feature_id, $name)
    {
        list($response) = $this->getBuildFeatureSettingWithHttpInfo($bt_locator, $feature_id, $name);
        return $response;
    }

    /**
     * Operation getBuildFeatureSettingWithHttpInfo
     *
     * Get the setting of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildFeatureSettingWithHttpInfo($bt_locator, $feature_id, $name)
    {
        $returnType = 'string';
        $request = $this->getBuildFeatureSettingRequest($bt_locator, $feature_id, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildFeatureSettingAsync
     *
     * Get the setting of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildFeatureSettingAsync($bt_locator, $feature_id, $name)
    {
        return $this->getBuildFeatureSettingAsyncWithHttpInfo($bt_locator, $feature_id, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildFeatureSettingAsyncWithHttpInfo
     *
     * Get the setting of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildFeatureSettingAsyncWithHttpInfo($bt_locator, $feature_id, $name)
    {
        $returnType = 'string';
        $request = $this->getBuildFeatureSettingRequest($bt_locator, $feature_id, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildFeatureSetting'
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildFeatureSettingRequest($bt_locator, $feature_id, $name)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getBuildFeatureSetting'
            );
        }
        // verify the required parameter 'feature_id' is set
        if ($feature_id === null || (is_array($feature_id) && count($feature_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_id when calling getBuildFeatureSetting'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getBuildFeatureSetting'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features/{featureId}/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($feature_id !== null) {
            $resourcePath = str_replace(
                '{' . 'featureId' . '}',
                ObjectSerializer::toPathValue($feature_id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildParameterOfBuildType
     *
     * Get build parameter.
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Property
     */
    public function getBuildParameterOfBuildType($name, $bt_locator, $fields = null)
    {
        list($response) = $this->getBuildParameterOfBuildTypeWithHttpInfo($name, $bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getBuildParameterOfBuildTypeWithHttpInfo
     *
     * Get build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Property, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildParameterOfBuildTypeWithHttpInfo($name, $bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Property';
        $request = $this->getBuildParameterOfBuildTypeRequest($name, $bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Property',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildParameterOfBuildTypeAsync
     *
     * Get build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildParameterOfBuildTypeAsync($name, $bt_locator, $fields = null)
    {
        return $this->getBuildParameterOfBuildTypeAsyncWithHttpInfo($name, $bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildParameterOfBuildTypeAsyncWithHttpInfo
     *
     * Get build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildParameterOfBuildTypeAsyncWithHttpInfo($name, $bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Property';
        $request = $this->getBuildParameterOfBuildTypeRequest($name, $bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildParameterOfBuildType'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildParameterOfBuildTypeRequest($name, $bt_locator, $fields = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getBuildParameterOfBuildType'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getBuildParameterOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildParameterSpecificationOfBuildType
     *
     * Get build parameter specification.
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getBuildParameterSpecificationOfBuildType($name, $bt_locator)
    {
        list($response) = $this->getBuildParameterSpecificationOfBuildTypeWithHttpInfo($name, $bt_locator);
        return $response;
    }

    /**
     * Operation getBuildParameterSpecificationOfBuildTypeWithHttpInfo
     *
     * Get build parameter specification.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildParameterSpecificationOfBuildTypeWithHttpInfo($name, $bt_locator)
    {
        $returnType = 'string';
        $request = $this->getBuildParameterSpecificationOfBuildTypeRequest($name, $bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildParameterSpecificationOfBuildTypeAsync
     *
     * Get build parameter specification.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildParameterSpecificationOfBuildTypeAsync($name, $bt_locator)
    {
        return $this->getBuildParameterSpecificationOfBuildTypeAsyncWithHttpInfo($name, $bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildParameterSpecificationOfBuildTypeAsyncWithHttpInfo
     *
     * Get build parameter specification.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildParameterSpecificationOfBuildTypeAsyncWithHttpInfo($name, $bt_locator)
    {
        $returnType = 'string';
        $request = $this->getBuildParameterSpecificationOfBuildTypeRequest($name, $bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildParameterSpecificationOfBuildType'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildParameterSpecificationOfBuildTypeRequest($name, $bt_locator)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getBuildParameterSpecificationOfBuildType'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getBuildParameterSpecificationOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters/{name}/type/rawValue';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildParameterTypeOfBuildType
     *
     * Get type of build parameter.
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Type
     */
    public function getBuildParameterTypeOfBuildType($name, $bt_locator)
    {
        list($response) = $this->getBuildParameterTypeOfBuildTypeWithHttpInfo($name, $bt_locator);
        return $response;
    }

    /**
     * Operation getBuildParameterTypeOfBuildTypeWithHttpInfo
     *
     * Get type of build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Type, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildParameterTypeOfBuildTypeWithHttpInfo($name, $bt_locator)
    {
        $returnType = '\Swagger\Client\Model\Type';
        $request = $this->getBuildParameterTypeOfBuildTypeRequest($name, $bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Type',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildParameterTypeOfBuildTypeAsync
     *
     * Get type of build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildParameterTypeOfBuildTypeAsync($name, $bt_locator)
    {
        return $this->getBuildParameterTypeOfBuildTypeAsyncWithHttpInfo($name, $bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildParameterTypeOfBuildTypeAsyncWithHttpInfo
     *
     * Get type of build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildParameterTypeOfBuildTypeAsyncWithHttpInfo($name, $bt_locator)
    {
        $returnType = '\Swagger\Client\Model\Type';
        $request = $this->getBuildParameterTypeOfBuildTypeRequest($name, $bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildParameterTypeOfBuildType'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildParameterTypeOfBuildTypeRequest($name, $bt_locator)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getBuildParameterTypeOfBuildType'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getBuildParameterTypeOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters/{name}/type';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildParameterValueOfBuildType
     *
     * Get value of build parameter.
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getBuildParameterValueOfBuildType($name, $bt_locator)
    {
        list($response) = $this->getBuildParameterValueOfBuildTypeWithHttpInfo($name, $bt_locator);
        return $response;
    }

    /**
     * Operation getBuildParameterValueOfBuildTypeWithHttpInfo
     *
     * Get value of build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildParameterValueOfBuildTypeWithHttpInfo($name, $bt_locator)
    {
        $returnType = 'string';
        $request = $this->getBuildParameterValueOfBuildTypeRequest($name, $bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildParameterValueOfBuildTypeAsync
     *
     * Get value of build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildParameterValueOfBuildTypeAsync($name, $bt_locator)
    {
        return $this->getBuildParameterValueOfBuildTypeAsyncWithHttpInfo($name, $bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildParameterValueOfBuildTypeAsyncWithHttpInfo
     *
     * Get value of build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildParameterValueOfBuildTypeAsyncWithHttpInfo($name, $bt_locator)
    {
        $returnType = 'string';
        $request = $this->getBuildParameterValueOfBuildTypeRequest($name, $bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildParameterValueOfBuildType'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildParameterValueOfBuildTypeRequest($name, $bt_locator)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getBuildParameterValueOfBuildType'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getBuildParameterValueOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters/{name}/value';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildParametersOfBuildType
     *
     * Get build parameters.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $locator locator (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Properties
     */
    public function getBuildParametersOfBuildType($bt_locator, $locator = null, $fields = null)
    {
        list($response) = $this->getBuildParametersOfBuildTypeWithHttpInfo($bt_locator, $locator, $fields);
        return $response;
    }

    /**
     * Operation getBuildParametersOfBuildTypeWithHttpInfo
     *
     * Get build parameters.
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Properties, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildParametersOfBuildTypeWithHttpInfo($bt_locator, $locator = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Properties';
        $request = $this->getBuildParametersOfBuildTypeRequest($bt_locator, $locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Properties',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildParametersOfBuildTypeAsync
     *
     * Get build parameters.
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildParametersOfBuildTypeAsync($bt_locator, $locator = null, $fields = null)
    {
        return $this->getBuildParametersOfBuildTypeAsyncWithHttpInfo($bt_locator, $locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildParametersOfBuildTypeAsyncWithHttpInfo
     *
     * Get build parameters.
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildParametersOfBuildTypeAsyncWithHttpInfo($bt_locator, $locator = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Properties';
        $request = $this->getBuildParametersOfBuildTypeRequest($bt_locator, $locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildParametersOfBuildType'
     *
     * @param  string $bt_locator (required)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildParametersOfBuildTypeRequest($bt_locator, $locator = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getBuildParametersOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildStep
     *
     * Get a build step of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $step_id step_id (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Step
     */
    public function getBuildStep($bt_locator, $step_id, $fields = null)
    {
        list($response) = $this->getBuildStepWithHttpInfo($bt_locator, $step_id, $fields);
        return $response;
    }

    /**
     * Operation getBuildStepWithHttpInfo
     *
     * Get a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Step, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildStepWithHttpInfo($bt_locator, $step_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Step';
        $request = $this->getBuildStepRequest($bt_locator, $step_id, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Step',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildStepAsync
     *
     * Get a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildStepAsync($bt_locator, $step_id, $fields = null)
    {
        return $this->getBuildStepAsyncWithHttpInfo($bt_locator, $step_id, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildStepAsyncWithHttpInfo
     *
     * Get a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildStepAsyncWithHttpInfo($bt_locator, $step_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Step';
        $request = $this->getBuildStepRequest($bt_locator, $step_id, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildStep'
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildStepRequest($bt_locator, $step_id, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getBuildStep'
            );
        }
        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling getBuildStep'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps/{stepId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildStepParameter
     *
     * Get a parameter of a build step of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $step_id step_id (required)
     * @param  string $parameter_name parameter_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getBuildStepParameter($bt_locator, $step_id, $parameter_name)
    {
        list($response) = $this->getBuildStepParameterWithHttpInfo($bt_locator, $step_id, $parameter_name);
        return $response;
    }

    /**
     * Operation getBuildStepParameterWithHttpInfo
     *
     * Get a parameter of a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $parameter_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildStepParameterWithHttpInfo($bt_locator, $step_id, $parameter_name)
    {
        $returnType = 'string';
        $request = $this->getBuildStepParameterRequest($bt_locator, $step_id, $parameter_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildStepParameterAsync
     *
     * Get a parameter of a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $parameter_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildStepParameterAsync($bt_locator, $step_id, $parameter_name)
    {
        return $this->getBuildStepParameterAsyncWithHttpInfo($bt_locator, $step_id, $parameter_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildStepParameterAsyncWithHttpInfo
     *
     * Get a parameter of a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $parameter_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildStepParameterAsyncWithHttpInfo($bt_locator, $step_id, $parameter_name)
    {
        $returnType = 'string';
        $request = $this->getBuildStepParameterRequest($bt_locator, $step_id, $parameter_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildStepParameter'
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $parameter_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildStepParameterRequest($bt_locator, $step_id, $parameter_name)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getBuildStepParameter'
            );
        }
        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling getBuildStepParameter'
            );
        }
        // verify the required parameter 'parameter_name' is set
        if ($parameter_name === null || (is_array($parameter_name) && count($parameter_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parameter_name when calling getBuildStepParameter'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps/{stepId}/parameters/{parameterName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }
        // path params
        if ($parameter_name !== null) {
            $resourcePath = str_replace(
                '{' . 'parameterName' . '}',
                ObjectSerializer::toPathValue($parameter_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildStepSetting
     *
     * Get the setting of a build step of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $step_id step_id (required)
     * @param  string $field_name field_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getBuildStepSetting($bt_locator, $step_id, $field_name)
    {
        list($response) = $this->getBuildStepSettingWithHttpInfo($bt_locator, $step_id, $field_name);
        return $response;
    }

    /**
     * Operation getBuildStepSettingWithHttpInfo
     *
     * Get the setting of a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $field_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildStepSettingWithHttpInfo($bt_locator, $step_id, $field_name)
    {
        $returnType = 'string';
        $request = $this->getBuildStepSettingRequest($bt_locator, $step_id, $field_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildStepSettingAsync
     *
     * Get the setting of a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildStepSettingAsync($bt_locator, $step_id, $field_name)
    {
        return $this->getBuildStepSettingAsyncWithHttpInfo($bt_locator, $step_id, $field_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildStepSettingAsyncWithHttpInfo
     *
     * Get the setting of a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildStepSettingAsyncWithHttpInfo($bt_locator, $step_id, $field_name)
    {
        $returnType = 'string';
        $request = $this->getBuildStepSettingRequest($bt_locator, $step_id, $field_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildStepSetting'
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildStepSettingRequest($bt_locator, $step_id, $field_name)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getBuildStepSetting'
            );
        }
        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling getBuildStepSetting'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null || (is_array($field_name) && count($field_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling getBuildStepSetting'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps/{stepId}/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildTemplate
     *
     * Get a template of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $template_locator template_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\BuildType
     */
    public function getBuildTemplate($bt_locator, $template_locator, $fields = null)
    {
        list($response) = $this->getBuildTemplateWithHttpInfo($bt_locator, $template_locator, $fields);
        return $response;
    }

    /**
     * Operation getBuildTemplateWithHttpInfo
     *
     * Get a template of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $template_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\BuildType, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildTemplateWithHttpInfo($bt_locator, $template_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\BuildType';
        $request = $this->getBuildTemplateRequest($bt_locator, $template_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\BuildType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildTemplateAsync
     *
     * Get a template of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $template_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildTemplateAsync($bt_locator, $template_locator, $fields = null)
    {
        return $this->getBuildTemplateAsyncWithHttpInfo($bt_locator, $template_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildTemplateAsyncWithHttpInfo
     *
     * Get a template of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $template_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildTemplateAsyncWithHttpInfo($bt_locator, $template_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\BuildType';
        $request = $this->getBuildTemplateRequest($bt_locator, $template_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildTemplate'
     *
     * @param  string $bt_locator (required)
     * @param  string $template_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildTemplateRequest($bt_locator, $template_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getBuildTemplate'
            );
        }
        // verify the required parameter 'template_locator' is set
        if ($template_locator === null || (is_array($template_locator) && count($template_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_locator when calling getBuildTemplate'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/templates/{templateLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($template_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'templateLocator' . '}',
                ObjectSerializer::toPathValue($template_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildType
     *
     * Get build configuration matching the locator.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\BuildType
     */
    public function getBuildType($bt_locator, $fields = null)
    {
        list($response) = $this->getBuildTypeWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getBuildTypeWithHttpInfo
     *
     * Get build configuration matching the locator.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\BuildType, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildTypeWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\BuildType';
        $request = $this->getBuildTypeRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\BuildType',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildTypeAsync
     *
     * Get build configuration matching the locator.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildTypeAsync($bt_locator, $fields = null)
    {
        return $this->getBuildTypeAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildTypeAsyncWithHttpInfo
     *
     * Get build configuration matching the locator.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildTypeAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\BuildType';
        $request = $this->getBuildTypeRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildType'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildTypeRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildTypeBuildTags
     *
     * Get tags of builds of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $field field (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Tags
     */
    public function getBuildTypeBuildTags($bt_locator, $field = null)
    {
        list($response) = $this->getBuildTypeBuildTagsWithHttpInfo($bt_locator, $field);
        return $response;
    }

    /**
     * Operation getBuildTypeBuildTagsWithHttpInfo
     *
     * Get tags of builds of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $field (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Tags, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildTypeBuildTagsWithHttpInfo($bt_locator, $field = null)
    {
        $returnType = '\Swagger\Client\Model\Tags';
        $request = $this->getBuildTypeBuildTagsRequest($bt_locator, $field);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Tags',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildTypeBuildTagsAsync
     *
     * Get tags of builds of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $field (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildTypeBuildTagsAsync($bt_locator, $field = null)
    {
        return $this->getBuildTypeBuildTagsAsyncWithHttpInfo($bt_locator, $field)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildTypeBuildTagsAsyncWithHttpInfo
     *
     * Get tags of builds of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $field (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildTypeBuildTagsAsyncWithHttpInfo($bt_locator, $field = null)
    {
        $returnType = '\Swagger\Client\Model\Tags';
        $request = $this->getBuildTypeBuildTagsRequest($bt_locator, $field);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildTypeBuildTags'
     *
     * @param  string $bt_locator (required)
     * @param  string $field (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildTypeBuildTagsRequest($bt_locator, $field = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getBuildTypeBuildTags'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/buildTags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($field !== null) {
            $queryParams['field'] = ObjectSerializer::toQueryValue($field);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildTypeBuilds
     *
     * Get builds of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Builds
     */
    public function getBuildTypeBuilds($bt_locator, $fields = null)
    {
        list($response) = $this->getBuildTypeBuildsWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getBuildTypeBuildsWithHttpInfo
     *
     * Get builds of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Builds, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildTypeBuildsWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Builds';
        $request = $this->getBuildTypeBuildsRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Builds',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildTypeBuildsAsync
     *
     * Get builds of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildTypeBuildsAsync($bt_locator, $fields = null)
    {
        return $this->getBuildTypeBuildsAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildTypeBuildsAsyncWithHttpInfo
     *
     * Get builds of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildTypeBuildsAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Builds';
        $request = $this->getBuildTypeBuildsRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildTypeBuilds'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildTypeBuildsRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getBuildTypeBuilds'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/builds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildTypeField
     *
     * Get a field of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $field field (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getBuildTypeField($bt_locator, $field)
    {
        list($response) = $this->getBuildTypeFieldWithHttpInfo($bt_locator, $field);
        return $response;
    }

    /**
     * Operation getBuildTypeFieldWithHttpInfo
     *
     * Get a field of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildTypeFieldWithHttpInfo($bt_locator, $field)
    {
        $returnType = 'string';
        $request = $this->getBuildTypeFieldRequest($bt_locator, $field);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildTypeFieldAsync
     *
     * Get a field of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildTypeFieldAsync($bt_locator, $field)
    {
        return $this->getBuildTypeFieldAsyncWithHttpInfo($bt_locator, $field)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildTypeFieldAsyncWithHttpInfo
     *
     * Get a field of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildTypeFieldAsyncWithHttpInfo($bt_locator, $field)
    {
        $returnType = 'string';
        $request = $this->getBuildTypeFieldRequest($bt_locator, $field);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildTypeField'
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildTypeFieldRequest($bt_locator, $field)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getBuildTypeField'
            );
        }
        // verify the required parameter 'field' is set
        if ($field === null || (is_array($field) && count($field) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field when calling getBuildTypeField'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/{field}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($field !== null) {
            $resourcePath = str_replace(
                '{' . 'field' . '}',
                ObjectSerializer::toPathValue($field),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBuildTypeSettingsFile
     *
     * Get the settings file of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getBuildTypeSettingsFile($bt_locator)
    {
        list($response) = $this->getBuildTypeSettingsFileWithHttpInfo($bt_locator);
        return $response;
    }

    /**
     * Operation getBuildTypeSettingsFileWithHttpInfo
     *
     * Get the settings file of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBuildTypeSettingsFileWithHttpInfo($bt_locator)
    {
        $returnType = 'string';
        $request = $this->getBuildTypeSettingsFileRequest($bt_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBuildTypeSettingsFileAsync
     *
     * Get the settings file of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildTypeSettingsFileAsync($bt_locator)
    {
        return $this->getBuildTypeSettingsFileAsyncWithHttpInfo($bt_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBuildTypeSettingsFileAsyncWithHttpInfo
     *
     * Get the settings file of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBuildTypeSettingsFileAsyncWithHttpInfo($bt_locator)
    {
        $returnType = 'string';
        $request = $this->getBuildTypeSettingsFileRequest($bt_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBuildTypeSettingsFile'
     *
     * @param  string $bt_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getBuildTypeSettingsFileRequest($bt_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getBuildTypeSettingsFile'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/settingsFile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFileMetadataOfBuildType
     *
     * Get metadata of specific file.
     *
     * @param  string $path path (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  bool $resolve_parameters resolve_parameters (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\\SplFileObject
     */
    public function getFileMetadataOfBuildType($path, $bt_locator, $fields = null, $resolve_parameters = null)
    {
        list($response) = $this->getFileMetadataOfBuildTypeWithHttpInfo($path, $bt_locator, $fields, $resolve_parameters);
        return $response;
    }

    /**
     * Operation getFileMetadataOfBuildTypeWithHttpInfo
     *
     * Get metadata of specific file.
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\\SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileMetadataOfBuildTypeWithHttpInfo($path, $bt_locator, $fields = null, $resolve_parameters = null)
    {
        $returnType = '\Swagger\Client\Model\\SplFileObject';
        $request = $this->getFileMetadataOfBuildTypeRequest($path, $bt_locator, $fields, $resolve_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFileMetadataOfBuildTypeAsync
     *
     * Get metadata of specific file.
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileMetadataOfBuildTypeAsync($path, $bt_locator, $fields = null, $resolve_parameters = null)
    {
        return $this->getFileMetadataOfBuildTypeAsyncWithHttpInfo($path, $bt_locator, $fields, $resolve_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileMetadataOfBuildTypeAsyncWithHttpInfo
     *
     * Get metadata of specific file.
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileMetadataOfBuildTypeAsyncWithHttpInfo($path, $bt_locator, $fields = null, $resolve_parameters = null)
    {
        $returnType = '\Swagger\Client\Model\\SplFileObject';
        $request = $this->getFileMetadataOfBuildTypeRequest($path, $bt_locator, $fields, $resolve_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFileMetadataOfBuildType'
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFileMetadataOfBuildTypeRequest($path, $bt_locator, $fields = null, $resolve_parameters = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getFileMetadataOfBuildType'
            );
        }
        if (!preg_match("/(\/.*)?/", $path)) {
            throw new \InvalidArgumentException("invalid value for \"path\" when calling BuildTypeApi.getFileMetadataOfBuildType, must conform to the pattern /(\/.*)?/.");
        }

        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getFileMetadataOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs/files/latest/metadata{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($resolve_parameters !== null) {
            $queryParams['resolveParameters'] = ObjectSerializer::toQueryValue($resolve_parameters);
        }

        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFilesListForSubpathOfBuildType
     *
     * List files under this path.
     *
     * @param  string $path path (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  string $base_path base_path (optional)
     * @param  string $locator locator (optional)
     * @param  string $fields fields (optional)
     * @param  bool $resolve_parameters resolve_parameters (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Files
     */
    public function getFilesListForSubpathOfBuildType($path, $bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        list($response) = $this->getFilesListForSubpathOfBuildTypeWithHttpInfo($path, $bt_locator, $base_path, $locator, $fields, $resolve_parameters);
        return $response;
    }

    /**
     * Operation getFilesListForSubpathOfBuildTypeWithHttpInfo
     *
     * List files under this path.
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Files, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFilesListForSubpathOfBuildTypeWithHttpInfo($path, $bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        $returnType = '\Swagger\Client\Model\Files';
        $request = $this->getFilesListForSubpathOfBuildTypeRequest($path, $bt_locator, $base_path, $locator, $fields, $resolve_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Files',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFilesListForSubpathOfBuildTypeAsync
     *
     * List files under this path.
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesListForSubpathOfBuildTypeAsync($path, $bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        return $this->getFilesListForSubpathOfBuildTypeAsyncWithHttpInfo($path, $bt_locator, $base_path, $locator, $fields, $resolve_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFilesListForSubpathOfBuildTypeAsyncWithHttpInfo
     *
     * List files under this path.
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesListForSubpathOfBuildTypeAsyncWithHttpInfo($path, $bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        $returnType = '\Swagger\Client\Model\Files';
        $request = $this->getFilesListForSubpathOfBuildTypeRequest($path, $bt_locator, $base_path, $locator, $fields, $resolve_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFilesListForSubpathOfBuildType'
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFilesListForSubpathOfBuildTypeRequest($path, $bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getFilesListForSubpathOfBuildType'
            );
        }
        if (!preg_match("/(.*)?/", $path)) {
            throw new \InvalidArgumentException("invalid value for \"path\" when calling BuildTypeApi.getFilesListForSubpathOfBuildType, must conform to the pattern /(.*)?/.");
        }

        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getFilesListForSubpathOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs/files/latest/{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($base_path !== null) {
            $queryParams['basePath'] = ObjectSerializer::toQueryValue($base_path);
        }
        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($resolve_parameters !== null) {
            $queryParams['resolveParameters'] = ObjectSerializer::toQueryValue($resolve_parameters);
        }

        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFilesListOfBuildType
     *
     * List all files.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $base_path base_path (optional)
     * @param  string $locator locator (optional)
     * @param  string $fields fields (optional)
     * @param  bool $resolve_parameters resolve_parameters (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Files
     */
    public function getFilesListOfBuildType($bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        list($response) = $this->getFilesListOfBuildTypeWithHttpInfo($bt_locator, $base_path, $locator, $fields, $resolve_parameters);
        return $response;
    }

    /**
     * Operation getFilesListOfBuildTypeWithHttpInfo
     *
     * List all files.
     *
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Files, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFilesListOfBuildTypeWithHttpInfo($bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        $returnType = '\Swagger\Client\Model\Files';
        $request = $this->getFilesListOfBuildTypeRequest($bt_locator, $base_path, $locator, $fields, $resolve_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Files',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFilesListOfBuildTypeAsync
     *
     * List all files.
     *
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesListOfBuildTypeAsync($bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        return $this->getFilesListOfBuildTypeAsyncWithHttpInfo($bt_locator, $base_path, $locator, $fields, $resolve_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFilesListOfBuildTypeAsyncWithHttpInfo
     *
     * List all files.
     *
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesListOfBuildTypeAsyncWithHttpInfo($bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        $returnType = '\Swagger\Client\Model\Files';
        $request = $this->getFilesListOfBuildTypeRequest($bt_locator, $base_path, $locator, $fields, $resolve_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFilesListOfBuildType'
     *
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $fields (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFilesListOfBuildTypeRequest($bt_locator, $base_path = null, $locator = null, $fields = null, $resolve_parameters = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getFilesListOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs/files/latest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($base_path !== null) {
            $queryParams['basePath'] = ObjectSerializer::toQueryValue($base_path);
        }
        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($resolve_parameters !== null) {
            $queryParams['resolveParameters'] = ObjectSerializer::toQueryValue($resolve_parameters);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSnapshotDependency
     *
     * Get a snapshot dependency of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $snapshot_dep_locator snapshot_dep_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SnapshotDependency
     */
    public function getSnapshotDependency($bt_locator, $snapshot_dep_locator, $fields = null)
    {
        list($response) = $this->getSnapshotDependencyWithHttpInfo($bt_locator, $snapshot_dep_locator, $fields);
        return $response;
    }

    /**
     * Operation getSnapshotDependencyWithHttpInfo
     *
     * Get a snapshot dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SnapshotDependency, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSnapshotDependencyWithHttpInfo($bt_locator, $snapshot_dep_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\SnapshotDependency';
        $request = $this->getSnapshotDependencyRequest($bt_locator, $snapshot_dep_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SnapshotDependency',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSnapshotDependencyAsync
     *
     * Get a snapshot dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSnapshotDependencyAsync($bt_locator, $snapshot_dep_locator, $fields = null)
    {
        return $this->getSnapshotDependencyAsyncWithHttpInfo($bt_locator, $snapshot_dep_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSnapshotDependencyAsyncWithHttpInfo
     *
     * Get a snapshot dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSnapshotDependencyAsyncWithHttpInfo($bt_locator, $snapshot_dep_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\SnapshotDependency';
        $request = $this->getSnapshotDependencyRequest($bt_locator, $snapshot_dep_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSnapshotDependency'
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSnapshotDependencyRequest($bt_locator, $snapshot_dep_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getSnapshotDependency'
            );
        }
        // verify the required parameter 'snapshot_dep_locator' is set
        if ($snapshot_dep_locator === null || (is_array($snapshot_dep_locator) && count($snapshot_dep_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $snapshot_dep_locator when calling getSnapshotDependency'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/snapshot-dependencies/{snapshotDepLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($snapshot_dep_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'snapshotDepLocator' . '}',
                ObjectSerializer::toPathValue($snapshot_dep_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTrigger
     *
     * Get a trigger of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $trigger_locator trigger_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Trigger
     */
    public function getTrigger($bt_locator, $trigger_locator, $fields = null)
    {
        list($response) = $this->getTriggerWithHttpInfo($bt_locator, $trigger_locator, $fields);
        return $response;
    }

    /**
     * Operation getTriggerWithHttpInfo
     *
     * Get a trigger of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Trigger, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTriggerWithHttpInfo($bt_locator, $trigger_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Trigger';
        $request = $this->getTriggerRequest($bt_locator, $trigger_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Trigger',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTriggerAsync
     *
     * Get a trigger of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTriggerAsync($bt_locator, $trigger_locator, $fields = null)
    {
        return $this->getTriggerAsyncWithHttpInfo($bt_locator, $trigger_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTriggerAsyncWithHttpInfo
     *
     * Get a trigger of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTriggerAsyncWithHttpInfo($bt_locator, $trigger_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Trigger';
        $request = $this->getTriggerRequest($bt_locator, $trigger_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTrigger'
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTriggerRequest($bt_locator, $trigger_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getTrigger'
            );
        }
        // verify the required parameter 'trigger_locator' is set
        if ($trigger_locator === null || (is_array($trigger_locator) && count($trigger_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trigger_locator when calling getTrigger'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/triggers/{triggerLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($trigger_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'triggerLocator' . '}',
                ObjectSerializer::toPathValue($trigger_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTriggerParameter
     *
     * Get a parameter of a trigger of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $trigger_locator trigger_locator (required)
     * @param  string $field_name field_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getTriggerParameter($bt_locator, $trigger_locator, $field_name)
    {
        list($response) = $this->getTriggerParameterWithHttpInfo($bt_locator, $trigger_locator, $field_name);
        return $response;
    }

    /**
     * Operation getTriggerParameterWithHttpInfo
     *
     * Get a parameter of a trigger of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTriggerParameterWithHttpInfo($bt_locator, $trigger_locator, $field_name)
    {
        $returnType = 'string';
        $request = $this->getTriggerParameterRequest($bt_locator, $trigger_locator, $field_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTriggerParameterAsync
     *
     * Get a parameter of a trigger of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTriggerParameterAsync($bt_locator, $trigger_locator, $field_name)
    {
        return $this->getTriggerParameterAsyncWithHttpInfo($bt_locator, $trigger_locator, $field_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTriggerParameterAsyncWithHttpInfo
     *
     * Get a parameter of a trigger of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTriggerParameterAsyncWithHttpInfo($bt_locator, $trigger_locator, $field_name)
    {
        $returnType = 'string';
        $request = $this->getTriggerParameterRequest($bt_locator, $trigger_locator, $field_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTriggerParameter'
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $field_name (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTriggerParameterRequest($bt_locator, $trigger_locator, $field_name)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getTriggerParameter'
            );
        }
        // verify the required parameter 'trigger_locator' is set
        if ($trigger_locator === null || (is_array($trigger_locator) && count($trigger_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trigger_locator when calling getTriggerParameter'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null || (is_array($field_name) && count($field_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling getTriggerParameter'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/triggers/{triggerLocator}/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($trigger_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'triggerLocator' . '}',
                ObjectSerializer::toPathValue($trigger_locator),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVcsRoot
     *
     * Get a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $vcs_root_locator vcs_root_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\VcsRootEntry
     */
    public function getVcsRoot($bt_locator, $vcs_root_locator, $fields = null)
    {
        list($response) = $this->getVcsRootWithHttpInfo($bt_locator, $vcs_root_locator, $fields);
        return $response;
    }

    /**
     * Operation getVcsRootWithHttpInfo
     *
     * Get a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\VcsRootEntry, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVcsRootWithHttpInfo($bt_locator, $vcs_root_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\VcsRootEntry';
        $request = $this->getVcsRootRequest($bt_locator, $vcs_root_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\VcsRootEntry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVcsRootAsync
     *
     * Get a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVcsRootAsync($bt_locator, $vcs_root_locator, $fields = null)
    {
        return $this->getVcsRootAsyncWithHttpInfo($bt_locator, $vcs_root_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVcsRootAsyncWithHttpInfo
     *
     * Get a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVcsRootAsyncWithHttpInfo($bt_locator, $vcs_root_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\VcsRootEntry';
        $request = $this->getVcsRootRequest($bt_locator, $vcs_root_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVcsRoot'
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVcsRootRequest($bt_locator, $vcs_root_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getVcsRoot'
            );
        }
        // verify the required parameter 'vcs_root_locator' is set
        if ($vcs_root_locator === null || (is_array($vcs_root_locator) && count($vcs_root_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vcs_root_locator when calling getVcsRoot'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs-root-entries/{vcsRootLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($vcs_root_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'vcsRootLocator' . '}',
                ObjectSerializer::toPathValue($vcs_root_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVcsRootCheckoutRules
     *
     * Get checkout rules of a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $vcs_root_locator vcs_root_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getVcsRootCheckoutRules($bt_locator, $vcs_root_locator)
    {
        list($response) = $this->getVcsRootCheckoutRulesWithHttpInfo($bt_locator, $vcs_root_locator);
        return $response;
    }

    /**
     * Operation getVcsRootCheckoutRulesWithHttpInfo
     *
     * Get checkout rules of a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVcsRootCheckoutRulesWithHttpInfo($bt_locator, $vcs_root_locator)
    {
        $returnType = 'string';
        $request = $this->getVcsRootCheckoutRulesRequest($bt_locator, $vcs_root_locator);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVcsRootCheckoutRulesAsync
     *
     * Get checkout rules of a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVcsRootCheckoutRulesAsync($bt_locator, $vcs_root_locator)
    {
        return $this->getVcsRootCheckoutRulesAsyncWithHttpInfo($bt_locator, $vcs_root_locator)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVcsRootCheckoutRulesAsyncWithHttpInfo
     *
     * Get checkout rules of a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVcsRootCheckoutRulesAsyncWithHttpInfo($bt_locator, $vcs_root_locator)
    {
        $returnType = 'string';
        $request = $this->getVcsRootCheckoutRulesRequest($bt_locator, $vcs_root_locator);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVcsRootCheckoutRules'
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVcsRootCheckoutRulesRequest($bt_locator, $vcs_root_locator)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getVcsRootCheckoutRules'
            );
        }
        // verify the required parameter 'vcs_root_locator' is set
        if ($vcs_root_locator === null || (is_array($vcs_root_locator) && count($vcs_root_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vcs_root_locator when calling getVcsRootCheckoutRules'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs-root-entries/{vcsRootLocator}/checkout-rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($vcs_root_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'vcsRootLocator' . '}',
                ObjectSerializer::toPathValue($vcs_root_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getVcsRootInstancesOfBuildType
     *
     * Get all VCS root instances of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\VcsRootInstances
     */
    public function getVcsRootInstancesOfBuildType($bt_locator, $fields = null)
    {
        list($response) = $this->getVcsRootInstancesOfBuildTypeWithHttpInfo($bt_locator, $fields);
        return $response;
    }

    /**
     * Operation getVcsRootInstancesOfBuildTypeWithHttpInfo
     *
     * Get all VCS root instances of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\VcsRootInstances, HTTP status code, HTTP response headers (array of strings)
     */
    public function getVcsRootInstancesOfBuildTypeWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\VcsRootInstances';
        $request = $this->getVcsRootInstancesOfBuildTypeRequest($bt_locator, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\VcsRootInstances',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getVcsRootInstancesOfBuildTypeAsync
     *
     * Get all VCS root instances of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVcsRootInstancesOfBuildTypeAsync($bt_locator, $fields = null)
    {
        return $this->getVcsRootInstancesOfBuildTypeAsyncWithHttpInfo($bt_locator, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getVcsRootInstancesOfBuildTypeAsyncWithHttpInfo
     *
     * Get all VCS root instances of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getVcsRootInstancesOfBuildTypeAsyncWithHttpInfo($bt_locator, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\VcsRootInstances';
        $request = $this->getVcsRootInstancesOfBuildTypeRequest($bt_locator, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getVcsRootInstancesOfBuildType'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getVcsRootInstancesOfBuildTypeRequest($bt_locator, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getVcsRootInstancesOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcsRootInstances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getZippedFileOfBuildType
     *
     * Get specific file zipped.
     *
     * @param  string $path path (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  string $base_path base_path (optional)
     * @param  string $locator locator (optional)
     * @param  string $name name (optional)
     * @param  bool $resolve_parameters resolve_parameters (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getZippedFileOfBuildType($path, $bt_locator, $base_path = null, $locator = null, $name = null, $resolve_parameters = null)
    {
        $this->getZippedFileOfBuildTypeWithHttpInfo($path, $bt_locator, $base_path, $locator, $name, $resolve_parameters);
    }

    /**
     * Operation getZippedFileOfBuildTypeWithHttpInfo
     *
     * Get specific file zipped.
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $name (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getZippedFileOfBuildTypeWithHttpInfo($path, $bt_locator, $base_path = null, $locator = null, $name = null, $resolve_parameters = null)
    {
        $returnType = '';
        $request = $this->getZippedFileOfBuildTypeRequest($path, $bt_locator, $base_path, $locator, $name, $resolve_parameters);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getZippedFileOfBuildTypeAsync
     *
     * Get specific file zipped.
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $name (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getZippedFileOfBuildTypeAsync($path, $bt_locator, $base_path = null, $locator = null, $name = null, $resolve_parameters = null)
    {
        return $this->getZippedFileOfBuildTypeAsyncWithHttpInfo($path, $bt_locator, $base_path, $locator, $name, $resolve_parameters)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getZippedFileOfBuildTypeAsyncWithHttpInfo
     *
     * Get specific file zipped.
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $name (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getZippedFileOfBuildTypeAsyncWithHttpInfo($path, $bt_locator, $base_path = null, $locator = null, $name = null, $resolve_parameters = null)
    {
        $returnType = '';
        $request = $this->getZippedFileOfBuildTypeRequest($path, $bt_locator, $base_path, $locator, $name, $resolve_parameters);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getZippedFileOfBuildType'
     *
     * @param  string $path (required)
     * @param  string $bt_locator (required)
     * @param  string $base_path (optional)
     * @param  string $locator (optional)
     * @param  string $name (optional)
     * @param  bool $resolve_parameters (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getZippedFileOfBuildTypeRequest($path, $bt_locator, $base_path = null, $locator = null, $name = null, $resolve_parameters = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null || (is_array($path) && count($path) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $path when calling getZippedFileOfBuildType'
            );
        }
        if (!preg_match("/(\/.*)?/", $path)) {
            throw new \InvalidArgumentException("invalid value for \"path\" when calling BuildTypeApi.getZippedFileOfBuildType, must conform to the pattern /(\/.*)?/.");
        }

        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling getZippedFileOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs/files/latest/archived{path}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($base_path !== null) {
            $queryParams['basePath'] = ObjectSerializer::toQueryValue($base_path);
        }
        // query params
        if ($locator !== null) {
            $queryParams['locator'] = ObjectSerializer::toQueryValue($locator);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($resolve_parameters !== null) {
            $queryParams['resolveParameters'] = ObjectSerializer::toQueryValue($resolve_parameters);
        }

        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                '{' . 'path' . '}',
                ObjectSerializer::toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeAllTemplates
     *
     * Detach all templates from the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  bool $inline_settings inline_settings (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function removeAllTemplates($bt_locator, $inline_settings = null)
    {
        $this->removeAllTemplatesWithHttpInfo($bt_locator, $inline_settings);
    }

    /**
     * Operation removeAllTemplatesWithHttpInfo
     *
     * Detach all templates from the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  bool $inline_settings (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeAllTemplatesWithHttpInfo($bt_locator, $inline_settings = null)
    {
        $returnType = '';
        $request = $this->removeAllTemplatesRequest($bt_locator, $inline_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation removeAllTemplatesAsync
     *
     * Detach all templates from the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  bool $inline_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeAllTemplatesAsync($bt_locator, $inline_settings = null)
    {
        return $this->removeAllTemplatesAsyncWithHttpInfo($bt_locator, $inline_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeAllTemplatesAsyncWithHttpInfo
     *
     * Detach all templates from the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  bool $inline_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeAllTemplatesAsyncWithHttpInfo($bt_locator, $inline_settings = null)
    {
        $returnType = '';
        $request = $this->removeAllTemplatesRequest($bt_locator, $inline_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeAllTemplates'
     *
     * @param  string $bt_locator (required)
     * @param  bool $inline_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function removeAllTemplatesRequest($bt_locator, $inline_settings = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling removeAllTemplates'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($inline_settings !== null) {
            $queryParams['inlineSettings'] = ObjectSerializer::toQueryValue($inline_settings);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeTemplate
     *
     * Detach a template from the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $template_locator template_locator (required)
     * @param  bool $inline_settings inline_settings (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function removeTemplate($bt_locator, $template_locator, $inline_settings = null)
    {
        $this->removeTemplateWithHttpInfo($bt_locator, $template_locator, $inline_settings);
    }

    /**
     * Operation removeTemplateWithHttpInfo
     *
     * Detach a template from the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $template_locator (required)
     * @param  bool $inline_settings (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeTemplateWithHttpInfo($bt_locator, $template_locator, $inline_settings = null)
    {
        $returnType = '';
        $request = $this->removeTemplateRequest($bt_locator, $template_locator, $inline_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation removeTemplateAsync
     *
     * Detach a template from the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $template_locator (required)
     * @param  bool $inline_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeTemplateAsync($bt_locator, $template_locator, $inline_settings = null)
    {
        return $this->removeTemplateAsyncWithHttpInfo($bt_locator, $template_locator, $inline_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeTemplateAsyncWithHttpInfo
     *
     * Detach a template from the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $template_locator (required)
     * @param  bool $inline_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeTemplateAsyncWithHttpInfo($bt_locator, $template_locator, $inline_settings = null)
    {
        $returnType = '';
        $request = $this->removeTemplateRequest($bt_locator, $template_locator, $inline_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeTemplate'
     *
     * @param  string $bt_locator (required)
     * @param  string $template_locator (required)
     * @param  bool $inline_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function removeTemplateRequest($bt_locator, $template_locator, $inline_settings = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling removeTemplate'
            );
        }
        // verify the required parameter 'template_locator' is set
        if ($template_locator === null || (is_array($template_locator) && count($template_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $template_locator when calling removeTemplate'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/templates/{templateLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($inline_settings !== null) {
            $queryParams['inlineSettings'] = ObjectSerializer::toQueryValue($inline_settings);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($template_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'templateLocator' . '}',
                ObjectSerializer::toPathValue($template_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceAgentRequirement
     *
     * Update an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $agent_requirement_locator agent_requirement_locator (required)
     * @param  string $fields fields (optional)
     * @param  \Swagger\Client\Model\AgentRequirement $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\AgentRequirement
     */
    public function replaceAgentRequirement($bt_locator, $agent_requirement_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceAgentRequirementWithHttpInfo($bt_locator, $agent_requirement_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceAgentRequirementWithHttpInfo
     *
     * Update an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\AgentRequirement $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\AgentRequirement, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceAgentRequirementWithHttpInfo($bt_locator, $agent_requirement_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\AgentRequirement';
        $request = $this->replaceAgentRequirementRequest($bt_locator, $agent_requirement_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AgentRequirement',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceAgentRequirementAsync
     *
     * Update an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\AgentRequirement $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAgentRequirementAsync($bt_locator, $agent_requirement_locator, $fields = null, $body = null)
    {
        return $this->replaceAgentRequirementAsyncWithHttpInfo($bt_locator, $agent_requirement_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceAgentRequirementAsyncWithHttpInfo
     *
     * Update an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\AgentRequirement $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAgentRequirementAsyncWithHttpInfo($bt_locator, $agent_requirement_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\AgentRequirement';
        $request = $this->replaceAgentRequirementRequest($bt_locator, $agent_requirement_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceAgentRequirement'
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\AgentRequirement $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceAgentRequirementRequest($bt_locator, $agent_requirement_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceAgentRequirement'
            );
        }
        // verify the required parameter 'agent_requirement_locator' is set
        if ($agent_requirement_locator === null || (is_array($agent_requirement_locator) && count($agent_requirement_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $agent_requirement_locator when calling replaceAgentRequirement'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/agent-requirements/{agentRequirementLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($agent_requirement_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'agentRequirementLocator' . '}',
                ObjectSerializer::toPathValue($agent_requirement_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceAllAgentRequirements
     *
     * Update all agent requirements of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \Swagger\Client\Model\AgentRequirements $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\AgentRequirements
     */
    public function replaceAllAgentRequirements($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceAllAgentRequirementsWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceAllAgentRequirementsWithHttpInfo
     *
     * Update all agent requirements of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\AgentRequirements $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\AgentRequirements, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceAllAgentRequirementsWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\AgentRequirements';
        $request = $this->replaceAllAgentRequirementsRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\AgentRequirements',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceAllAgentRequirementsAsync
     *
     * Update all agent requirements of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\AgentRequirements $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAllAgentRequirementsAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->replaceAllAgentRequirementsAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceAllAgentRequirementsAsyncWithHttpInfo
     *
     * Update all agent requirements of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\AgentRequirements $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAllAgentRequirementsAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\AgentRequirements';
        $request = $this->replaceAllAgentRequirementsRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceAllAgentRequirements'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\AgentRequirements $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceAllAgentRequirementsRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceAllAgentRequirements'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/agent-requirements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceAllArtifactDependencies
     *
     * Update all artifact dependencies of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \Swagger\Client\Model\ArtifactDependencies $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ArtifactDependencies
     */
    public function replaceAllArtifactDependencies($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceAllArtifactDependenciesWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceAllArtifactDependenciesWithHttpInfo
     *
     * Update all artifact dependencies of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\ArtifactDependencies $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ArtifactDependencies, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceAllArtifactDependenciesWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\ArtifactDependencies';
        $request = $this->replaceAllArtifactDependenciesRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ArtifactDependencies',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceAllArtifactDependenciesAsync
     *
     * Update all artifact dependencies of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\ArtifactDependencies $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAllArtifactDependenciesAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->replaceAllArtifactDependenciesAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceAllArtifactDependenciesAsyncWithHttpInfo
     *
     * Update all artifact dependencies of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\ArtifactDependencies $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAllArtifactDependenciesAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\ArtifactDependencies';
        $request = $this->replaceAllArtifactDependenciesRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceAllArtifactDependencies'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\ArtifactDependencies $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceAllArtifactDependenciesRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceAllArtifactDependencies'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/artifact-dependencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceAllBuildFeatures
     *
     * Update all build features of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \Swagger\Client\Model\Features $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Features
     */
    public function replaceAllBuildFeatures($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceAllBuildFeaturesWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceAllBuildFeaturesWithHttpInfo
     *
     * Update all build features of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Features $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Features, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceAllBuildFeaturesWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Features';
        $request = $this->replaceAllBuildFeaturesRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Features',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceAllBuildFeaturesAsync
     *
     * Update all build features of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Features $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAllBuildFeaturesAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->replaceAllBuildFeaturesAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceAllBuildFeaturesAsyncWithHttpInfo
     *
     * Update all build features of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Features $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAllBuildFeaturesAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Features';
        $request = $this->replaceAllBuildFeaturesRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceAllBuildFeatures'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Features $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceAllBuildFeaturesRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceAllBuildFeatures'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceAllBuildSteps
     *
     * Update all build steps of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \Swagger\Client\Model\Steps $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Steps
     */
    public function replaceAllBuildSteps($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceAllBuildStepsWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceAllBuildStepsWithHttpInfo
     *
     * Update all build steps of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Steps $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Steps, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceAllBuildStepsWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Steps';
        $request = $this->replaceAllBuildStepsRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Steps',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceAllBuildStepsAsync
     *
     * Update all build steps of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Steps $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAllBuildStepsAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->replaceAllBuildStepsAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceAllBuildStepsAsyncWithHttpInfo
     *
     * Update all build steps of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Steps $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAllBuildStepsAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Steps';
        $request = $this->replaceAllBuildStepsRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceAllBuildSteps'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Steps $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceAllBuildStepsRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceAllBuildSteps'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceAllSnapshotDependencies
     *
     * Update all snapshot dependencies of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \Swagger\Client\Model\SnapshotDependencies $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SnapshotDependencies
     */
    public function replaceAllSnapshotDependencies($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceAllSnapshotDependenciesWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceAllSnapshotDependenciesWithHttpInfo
     *
     * Update all snapshot dependencies of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\SnapshotDependencies $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SnapshotDependencies, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceAllSnapshotDependenciesWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\SnapshotDependencies';
        $request = $this->replaceAllSnapshotDependenciesRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SnapshotDependencies',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceAllSnapshotDependenciesAsync
     *
     * Update all snapshot dependencies of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\SnapshotDependencies $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAllSnapshotDependenciesAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->replaceAllSnapshotDependenciesAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceAllSnapshotDependenciesAsyncWithHttpInfo
     *
     * Update all snapshot dependencies of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\SnapshotDependencies $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAllSnapshotDependenciesAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\SnapshotDependencies';
        $request = $this->replaceAllSnapshotDependenciesRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceAllSnapshotDependencies'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\SnapshotDependencies $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceAllSnapshotDependenciesRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceAllSnapshotDependencies'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/snapshot-dependencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceAllTriggers
     *
     * Update all triggers of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $fields fields (optional)
     * @param  \Swagger\Client\Model\Triggers $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Triggers
     */
    public function replaceAllTriggers($bt_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceAllTriggersWithHttpInfo($bt_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceAllTriggersWithHttpInfo
     *
     * Update all triggers of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Triggers $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Triggers, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceAllTriggersWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Triggers';
        $request = $this->replaceAllTriggersRequest($bt_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Triggers',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceAllTriggersAsync
     *
     * Update all triggers of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Triggers $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAllTriggersAsync($bt_locator, $fields = null, $body = null)
    {
        return $this->replaceAllTriggersAsyncWithHttpInfo($bt_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceAllTriggersAsyncWithHttpInfo
     *
     * Update all triggers of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Triggers $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAllTriggersAsyncWithHttpInfo($bt_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Triggers';
        $request = $this->replaceAllTriggersRequest($bt_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceAllTriggers'
     *
     * @param  string $bt_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Triggers $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceAllTriggersRequest($bt_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceAllTriggers'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/triggers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceAllVcsRoots
     *
     * Update all VCS roots of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  \Swagger\Client\Model\VcsRootEntries $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\VcsRootEntries
     */
    public function replaceAllVcsRoots($bt_locator, $body = null, $fields = null)
    {
        list($response) = $this->replaceAllVcsRootsWithHttpInfo($bt_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation replaceAllVcsRootsWithHttpInfo
     *
     * Update all VCS roots of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\VcsRootEntries $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\VcsRootEntries, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceAllVcsRootsWithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\VcsRootEntries';
        $request = $this->replaceAllVcsRootsRequest($bt_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\VcsRootEntries',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceAllVcsRootsAsync
     *
     * Update all VCS roots of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\VcsRootEntries $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAllVcsRootsAsync($bt_locator, $body = null, $fields = null)
    {
        return $this->replaceAllVcsRootsAsyncWithHttpInfo($bt_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceAllVcsRootsAsyncWithHttpInfo
     *
     * Update all VCS roots of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\VcsRootEntries $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAllVcsRootsAsyncWithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\VcsRootEntries';
        $request = $this->replaceAllVcsRootsRequest($bt_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceAllVcsRoots'
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\VcsRootEntries $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceAllVcsRootsRequest($bt_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceAllVcsRoots'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs-root-entries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceArtifactDependency
     *
     * Update an artifact dependency of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $artifact_dep_locator artifact_dep_locator (required)
     * @param  string $fields fields (optional)
     * @param  \Swagger\Client\Model\ArtifactDependency $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ArtifactDependency
     */
    public function replaceArtifactDependency($bt_locator, $artifact_dep_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceArtifactDependencyWithHttpInfo($bt_locator, $artifact_dep_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceArtifactDependencyWithHttpInfo
     *
     * Update an artifact dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\ArtifactDependency $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ArtifactDependency, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceArtifactDependencyWithHttpInfo($bt_locator, $artifact_dep_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\ArtifactDependency';
        $request = $this->replaceArtifactDependencyRequest($bt_locator, $artifact_dep_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ArtifactDependency',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceArtifactDependencyAsync
     *
     * Update an artifact dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\ArtifactDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceArtifactDependencyAsync($bt_locator, $artifact_dep_locator, $fields = null, $body = null)
    {
        return $this->replaceArtifactDependencyAsyncWithHttpInfo($bt_locator, $artifact_dep_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceArtifactDependencyAsyncWithHttpInfo
     *
     * Update an artifact dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\ArtifactDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceArtifactDependencyAsyncWithHttpInfo($bt_locator, $artifact_dep_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\ArtifactDependency';
        $request = $this->replaceArtifactDependencyRequest($bt_locator, $artifact_dep_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceArtifactDependency'
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\ArtifactDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceArtifactDependencyRequest($bt_locator, $artifact_dep_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceArtifactDependency'
            );
        }
        // verify the required parameter 'artifact_dep_locator' is set
        if ($artifact_dep_locator === null || (is_array($artifact_dep_locator) && count($artifact_dep_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $artifact_dep_locator when calling replaceArtifactDependency'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/artifact-dependencies/{artifactDepLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($artifact_dep_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'artifactDepLocator' . '}',
                ObjectSerializer::toPathValue($artifact_dep_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceBuildFeature
     *
     * Update a build feature of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $feature_id feature_id (required)
     * @param  string $fields fields (optional)
     * @param  \Swagger\Client\Model\Feature $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Feature
     */
    public function replaceBuildFeature($bt_locator, $feature_id, $fields = null, $body = null)
    {
        list($response) = $this->replaceBuildFeatureWithHttpInfo($bt_locator, $feature_id, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceBuildFeatureWithHttpInfo
     *
     * Update a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Feature $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Feature, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceBuildFeatureWithHttpInfo($bt_locator, $feature_id, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Feature';
        $request = $this->replaceBuildFeatureRequest($bt_locator, $feature_id, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Feature',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceBuildFeatureAsync
     *
     * Update a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Feature $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceBuildFeatureAsync($bt_locator, $feature_id, $fields = null, $body = null)
    {
        return $this->replaceBuildFeatureAsyncWithHttpInfo($bt_locator, $feature_id, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceBuildFeatureAsyncWithHttpInfo
     *
     * Update a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Feature $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceBuildFeatureAsyncWithHttpInfo($bt_locator, $feature_id, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Feature';
        $request = $this->replaceBuildFeatureRequest($bt_locator, $feature_id, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceBuildFeature'
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Feature $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceBuildFeatureRequest($bt_locator, $feature_id, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceBuildFeature'
            );
        }
        // verify the required parameter 'feature_id' is set
        if ($feature_id === null || (is_array($feature_id) && count($feature_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_id when calling replaceBuildFeature'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features/{featureId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($feature_id !== null) {
            $resourcePath = str_replace(
                '{' . 'featureId' . '}',
                ObjectSerializer::toPathValue($feature_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceBuildFeatureParameters
     *
     * Update a parameter of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $feature_id feature_id (required)
     * @param  \Swagger\Client\Model\Properties $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Properties
     */
    public function replaceBuildFeatureParameters($bt_locator, $feature_id, $body = null, $fields = null)
    {
        list($response) = $this->replaceBuildFeatureParametersWithHttpInfo($bt_locator, $feature_id, $body, $fields);
        return $response;
    }

    /**
     * Operation replaceBuildFeatureParametersWithHttpInfo
     *
     * Update a parameter of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  \Swagger\Client\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Properties, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceBuildFeatureParametersWithHttpInfo($bt_locator, $feature_id, $body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Properties';
        $request = $this->replaceBuildFeatureParametersRequest($bt_locator, $feature_id, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Properties',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceBuildFeatureParametersAsync
     *
     * Update a parameter of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  \Swagger\Client\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceBuildFeatureParametersAsync($bt_locator, $feature_id, $body = null, $fields = null)
    {
        return $this->replaceBuildFeatureParametersAsyncWithHttpInfo($bt_locator, $feature_id, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceBuildFeatureParametersAsyncWithHttpInfo
     *
     * Update a parameter of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  \Swagger\Client\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceBuildFeatureParametersAsyncWithHttpInfo($bt_locator, $feature_id, $body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Properties';
        $request = $this->replaceBuildFeatureParametersRequest($bt_locator, $feature_id, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceBuildFeatureParameters'
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  \Swagger\Client\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceBuildFeatureParametersRequest($bt_locator, $feature_id, $body = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceBuildFeatureParameters'
            );
        }
        // verify the required parameter 'feature_id' is set
        if ($feature_id === null || (is_array($feature_id) && count($feature_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_id when calling replaceBuildFeatureParameters'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features/{featureId}/parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($feature_id !== null) {
            $resourcePath = str_replace(
                '{' . 'featureId' . '}',
                ObjectSerializer::toPathValue($feature_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceBuildStep
     *
     * Replace a build step of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $step_id step_id (required)
     * @param  string $fields fields (optional)
     * @param  \Swagger\Client\Model\Step $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Step
     */
    public function replaceBuildStep($bt_locator, $step_id, $fields = null, $body = null)
    {
        list($response) = $this->replaceBuildStepWithHttpInfo($bt_locator, $step_id, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceBuildStepWithHttpInfo
     *
     * Replace a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Step $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Step, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceBuildStepWithHttpInfo($bt_locator, $step_id, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Step';
        $request = $this->replaceBuildStepRequest($bt_locator, $step_id, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Step',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceBuildStepAsync
     *
     * Replace a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Step $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceBuildStepAsync($bt_locator, $step_id, $fields = null, $body = null)
    {
        return $this->replaceBuildStepAsyncWithHttpInfo($bt_locator, $step_id, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceBuildStepAsyncWithHttpInfo
     *
     * Replace a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Step $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceBuildStepAsyncWithHttpInfo($bt_locator, $step_id, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Step';
        $request = $this->replaceBuildStepRequest($bt_locator, $step_id, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceBuildStep'
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Step $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceBuildStepRequest($bt_locator, $step_id, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceBuildStep'
            );
        }
        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling replaceBuildStep'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps/{stepId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceSnapshotDependency
     *
     * Update a snapshot dependency of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $snapshot_dep_locator snapshot_dep_locator (required)
     * @param  string $fields fields (optional)
     * @param  \Swagger\Client\Model\SnapshotDependency $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SnapshotDependency
     */
    public function replaceSnapshotDependency($bt_locator, $snapshot_dep_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceSnapshotDependencyWithHttpInfo($bt_locator, $snapshot_dep_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceSnapshotDependencyWithHttpInfo
     *
     * Update a snapshot dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\SnapshotDependency $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SnapshotDependency, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceSnapshotDependencyWithHttpInfo($bt_locator, $snapshot_dep_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\SnapshotDependency';
        $request = $this->replaceSnapshotDependencyRequest($bt_locator, $snapshot_dep_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SnapshotDependency',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceSnapshotDependencyAsync
     *
     * Update a snapshot dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\SnapshotDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceSnapshotDependencyAsync($bt_locator, $snapshot_dep_locator, $fields = null, $body = null)
    {
        return $this->replaceSnapshotDependencyAsyncWithHttpInfo($bt_locator, $snapshot_dep_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceSnapshotDependencyAsyncWithHttpInfo
     *
     * Update a snapshot dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\SnapshotDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceSnapshotDependencyAsyncWithHttpInfo($bt_locator, $snapshot_dep_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\SnapshotDependency';
        $request = $this->replaceSnapshotDependencyRequest($bt_locator, $snapshot_dep_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceSnapshotDependency'
     *
     * @param  string $bt_locator (required)
     * @param  string $snapshot_dep_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\SnapshotDependency $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceSnapshotDependencyRequest($bt_locator, $snapshot_dep_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceSnapshotDependency'
            );
        }
        // verify the required parameter 'snapshot_dep_locator' is set
        if ($snapshot_dep_locator === null || (is_array($snapshot_dep_locator) && count($snapshot_dep_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $snapshot_dep_locator when calling replaceSnapshotDependency'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/snapshot-dependencies/{snapshotDepLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($snapshot_dep_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'snapshotDepLocator' . '}',
                ObjectSerializer::toPathValue($snapshot_dep_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceTrigger
     *
     * Update a trigger of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $trigger_locator trigger_locator (required)
     * @param  string $fields fields (optional)
     * @param  \Swagger\Client\Model\Trigger $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Trigger
     */
    public function replaceTrigger($bt_locator, $trigger_locator, $fields = null, $body = null)
    {
        list($response) = $this->replaceTriggerWithHttpInfo($bt_locator, $trigger_locator, $fields, $body);
        return $response;
    }

    /**
     * Operation replaceTriggerWithHttpInfo
     *
     * Update a trigger of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Trigger $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Trigger, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceTriggerWithHttpInfo($bt_locator, $trigger_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Trigger';
        $request = $this->replaceTriggerRequest($bt_locator, $trigger_locator, $fields, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Trigger',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation replaceTriggerAsync
     *
     * Update a trigger of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Trigger $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceTriggerAsync($bt_locator, $trigger_locator, $fields = null, $body = null)
    {
        return $this->replaceTriggerAsyncWithHttpInfo($bt_locator, $trigger_locator, $fields, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceTriggerAsyncWithHttpInfo
     *
     * Update a trigger of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Trigger $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceTriggerAsyncWithHttpInfo($bt_locator, $trigger_locator, $fields = null, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Trigger';
        $request = $this->replaceTriggerRequest($bt_locator, $trigger_locator, $fields, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceTrigger'
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $fields (optional)
     * @param  \Swagger\Client\Model\Trigger $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceTriggerRequest($bt_locator, $trigger_locator, $fields = null, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling replaceTrigger'
            );
        }
        // verify the required parameter 'trigger_locator' is set
        if ($trigger_locator === null || (is_array($trigger_locator) && count($trigger_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trigger_locator when calling replaceTrigger'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/triggers/{triggerLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($trigger_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'triggerLocator' . '}',
                ObjectSerializer::toPathValue($trigger_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setAgentRequirementParameter
     *
     * Update a parameter of an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $agent_requirement_locator agent_requirement_locator (required)
     * @param  string $field_name field_name (required)
     * @param  string $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function setAgentRequirementParameter($bt_locator, $agent_requirement_locator, $field_name, $body = null)
    {
        list($response) = $this->setAgentRequirementParameterWithHttpInfo($bt_locator, $agent_requirement_locator, $field_name, $body);
        return $response;
    }

    /**
     * Operation setAgentRequirementParameterWithHttpInfo
     *
     * Update a parameter of an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function setAgentRequirementParameterWithHttpInfo($bt_locator, $agent_requirement_locator, $field_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->setAgentRequirementParameterRequest($bt_locator, $agent_requirement_locator, $field_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setAgentRequirementParameterAsync
     *
     * Update a parameter of an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setAgentRequirementParameterAsync($bt_locator, $agent_requirement_locator, $field_name, $body = null)
    {
        return $this->setAgentRequirementParameterAsyncWithHttpInfo($bt_locator, $agent_requirement_locator, $field_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setAgentRequirementParameterAsyncWithHttpInfo
     *
     * Update a parameter of an agent requirement of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setAgentRequirementParameterAsyncWithHttpInfo($bt_locator, $agent_requirement_locator, $field_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->setAgentRequirementParameterRequest($bt_locator, $agent_requirement_locator, $field_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setAgentRequirementParameter'
     *
     * @param  string $bt_locator (required)
     * @param  string $agent_requirement_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setAgentRequirementParameterRequest($bt_locator, $agent_requirement_locator, $field_name, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setAgentRequirementParameter'
            );
        }
        // verify the required parameter 'agent_requirement_locator' is set
        if ($agent_requirement_locator === null || (is_array($agent_requirement_locator) && count($agent_requirement_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $agent_requirement_locator when calling setAgentRequirementParameter'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null || (is_array($field_name) && count($field_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling setAgentRequirementParameter'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/agent-requirements/{agentRequirementLocator}/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($agent_requirement_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'agentRequirementLocator' . '}',
                ObjectSerializer::toPathValue($agent_requirement_locator),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setArtifactDependencyParameter
     *
     * Update a parameter of an artifact dependency of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $artifact_dep_locator artifact_dep_locator (required)
     * @param  string $field_name field_name (required)
     * @param  string $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function setArtifactDependencyParameter($bt_locator, $artifact_dep_locator, $field_name, $body = null)
    {
        list($response) = $this->setArtifactDependencyParameterWithHttpInfo($bt_locator, $artifact_dep_locator, $field_name, $body);
        return $response;
    }

    /**
     * Operation setArtifactDependencyParameterWithHttpInfo
     *
     * Update a parameter of an artifact dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function setArtifactDependencyParameterWithHttpInfo($bt_locator, $artifact_dep_locator, $field_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->setArtifactDependencyParameterRequest($bt_locator, $artifact_dep_locator, $field_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setArtifactDependencyParameterAsync
     *
     * Update a parameter of an artifact dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setArtifactDependencyParameterAsync($bt_locator, $artifact_dep_locator, $field_name, $body = null)
    {
        return $this->setArtifactDependencyParameterAsyncWithHttpInfo($bt_locator, $artifact_dep_locator, $field_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setArtifactDependencyParameterAsyncWithHttpInfo
     *
     * Update a parameter of an artifact dependency of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setArtifactDependencyParameterAsyncWithHttpInfo($bt_locator, $artifact_dep_locator, $field_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->setArtifactDependencyParameterRequest($bt_locator, $artifact_dep_locator, $field_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setArtifactDependencyParameter'
     *
     * @param  string $bt_locator (required)
     * @param  string $artifact_dep_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setArtifactDependencyParameterRequest($bt_locator, $artifact_dep_locator, $field_name, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setArtifactDependencyParameter'
            );
        }
        // verify the required parameter 'artifact_dep_locator' is set
        if ($artifact_dep_locator === null || (is_array($artifact_dep_locator) && count($artifact_dep_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $artifact_dep_locator when calling setArtifactDependencyParameter'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null || (is_array($field_name) && count($field_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling setArtifactDependencyParameter'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/artifact-dependencies/{artifactDepLocator}/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($artifact_dep_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'artifactDepLocator' . '}',
                ObjectSerializer::toPathValue($artifact_dep_locator),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setBuildFeatureParameter
     *
     * Update a parameter of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $feature_id feature_id (required)
     * @param  string $name name (required)
     * @param  string $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function setBuildFeatureParameter($bt_locator, $feature_id, $name, $body = null)
    {
        list($response) = $this->setBuildFeatureParameterWithHttpInfo($bt_locator, $feature_id, $name, $body);
        return $response;
    }

    /**
     * Operation setBuildFeatureParameterWithHttpInfo
     *
     * Update a parameter of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $name (required)
     * @param  string $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function setBuildFeatureParameterWithHttpInfo($bt_locator, $feature_id, $name, $body = null)
    {
        $returnType = 'string';
        $request = $this->setBuildFeatureParameterRequest($bt_locator, $feature_id, $name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setBuildFeatureParameterAsync
     *
     * Update a parameter of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildFeatureParameterAsync($bt_locator, $feature_id, $name, $body = null)
    {
        return $this->setBuildFeatureParameterAsyncWithHttpInfo($bt_locator, $feature_id, $name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setBuildFeatureParameterAsyncWithHttpInfo
     *
     * Update a parameter of a build feature of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildFeatureParameterAsyncWithHttpInfo($bt_locator, $feature_id, $name, $body = null)
    {
        $returnType = 'string';
        $request = $this->setBuildFeatureParameterRequest($bt_locator, $feature_id, $name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setBuildFeatureParameter'
     *
     * @param  string $bt_locator (required)
     * @param  string $feature_id (required)
     * @param  string $name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setBuildFeatureParameterRequest($bt_locator, $feature_id, $name, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setBuildFeatureParameter'
            );
        }
        // verify the required parameter 'feature_id' is set
        if ($feature_id === null || (is_array($feature_id) && count($feature_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feature_id when calling setBuildFeatureParameter'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling setBuildFeatureParameter'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/features/{featureId}/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($feature_id !== null) {
            $resourcePath = str_replace(
                '{' . 'featureId' . '}',
                ObjectSerializer::toPathValue($feature_id),
                $resourcePath
            );
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setBuildStepParameter
     *
     * Update a parameter of a build step of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $step_id step_id (required)
     * @param  string $field_name field_name (required)
     * @param  string $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function setBuildStepParameter($bt_locator, $step_id, $field_name, $body = null)
    {
        list($response) = $this->setBuildStepParameterWithHttpInfo($bt_locator, $step_id, $field_name, $body);
        return $response;
    }

    /**
     * Operation setBuildStepParameterWithHttpInfo
     *
     * Update a parameter of a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function setBuildStepParameterWithHttpInfo($bt_locator, $step_id, $field_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->setBuildStepParameterRequest($bt_locator, $step_id, $field_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setBuildStepParameterAsync
     *
     * Update a parameter of a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildStepParameterAsync($bt_locator, $step_id, $field_name, $body = null)
    {
        return $this->setBuildStepParameterAsyncWithHttpInfo($bt_locator, $step_id, $field_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setBuildStepParameterAsyncWithHttpInfo
     *
     * Update a parameter of a build step of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildStepParameterAsyncWithHttpInfo($bt_locator, $step_id, $field_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->setBuildStepParameterRequest($bt_locator, $step_id, $field_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setBuildStepParameter'
     *
     * @param  string $bt_locator (required)
     * @param  string $step_id (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setBuildStepParameterRequest($bt_locator, $step_id, $field_name, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setBuildStepParameter'
            );
        }
        // verify the required parameter 'step_id' is set
        if ($step_id === null || (is_array($step_id) && count($step_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $step_id when calling setBuildStepParameter'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null || (is_array($field_name) && count($field_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling setBuildStepParameter'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/steps/{stepId}/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($step_id !== null) {
            $resourcePath = str_replace(
                '{' . 'stepId' . '}',
                ObjectSerializer::toPathValue($step_id),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setBuildTypeField
     *
     * Update a field of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $field field (required)
     * @param  string $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function setBuildTypeField($bt_locator, $field, $body = null)
    {
        list($response) = $this->setBuildTypeFieldWithHttpInfo($bt_locator, $field, $body);
        return $response;
    }

    /**
     * Operation setBuildTypeFieldWithHttpInfo
     *
     * Update a field of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     * @param  string $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function setBuildTypeFieldWithHttpInfo($bt_locator, $field, $body = null)
    {
        $returnType = 'string';
        $request = $this->setBuildTypeFieldRequest($bt_locator, $field, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setBuildTypeFieldAsync
     *
     * Update a field of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildTypeFieldAsync($bt_locator, $field, $body = null)
    {
        return $this->setBuildTypeFieldAsyncWithHttpInfo($bt_locator, $field, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setBuildTypeFieldAsyncWithHttpInfo
     *
     * Update a field of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildTypeFieldAsyncWithHttpInfo($bt_locator, $field, $body = null)
    {
        $returnType = 'string';
        $request = $this->setBuildTypeFieldRequest($bt_locator, $field, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setBuildTypeField'
     *
     * @param  string $bt_locator (required)
     * @param  string $field (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setBuildTypeFieldRequest($bt_locator, $field, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setBuildTypeField'
            );
        }
        // verify the required parameter 'field' is set
        if ($field === null || (is_array($field) && count($field) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field when calling setBuildTypeField'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/{field}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($field !== null) {
            $resourcePath = str_replace(
                '{' . 'field' . '}',
                ObjectSerializer::toPathValue($field),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setBuildTypeTemplates
     *
     * Update all templates of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  \Swagger\Client\Model\BuildTypes $body body (optional)
     * @param  bool $optimize_settings optimize_settings (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\BuildTypes
     */
    public function setBuildTypeTemplates($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        list($response) = $this->setBuildTypeTemplatesWithHttpInfo($bt_locator, $body, $optimize_settings, $fields);
        return $response;
    }

    /**
     * Operation setBuildTypeTemplatesWithHttpInfo
     *
     * Update all templates of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\BuildTypes $body (optional)
     * @param  bool $optimize_settings (optional)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\BuildTypes, HTTP status code, HTTP response headers (array of strings)
     */
    public function setBuildTypeTemplatesWithHttpInfo($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\BuildTypes';
        $request = $this->setBuildTypeTemplatesRequest($bt_locator, $body, $optimize_settings, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\BuildTypes',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setBuildTypeTemplatesAsync
     *
     * Update all templates of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\BuildTypes $body (optional)
     * @param  bool $optimize_settings (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildTypeTemplatesAsync($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        return $this->setBuildTypeTemplatesAsyncWithHttpInfo($bt_locator, $body, $optimize_settings, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setBuildTypeTemplatesAsyncWithHttpInfo
     *
     * Update all templates of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\BuildTypes $body (optional)
     * @param  bool $optimize_settings (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setBuildTypeTemplatesAsyncWithHttpInfo($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\BuildTypes';
        $request = $this->setBuildTypeTemplatesRequest($bt_locator, $body, $optimize_settings, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setBuildTypeTemplates'
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\BuildTypes $body (optional)
     * @param  bool $optimize_settings (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setBuildTypeTemplatesRequest($bt_locator, $body = null, $optimize_settings = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setBuildTypeTemplates'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($optimize_settings !== null) {
            $queryParams['optimizeSettings'] = ObjectSerializer::toQueryValue($optimize_settings);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setTriggerParameter
     *
     * Update a parameter of a trigger of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $trigger_locator trigger_locator (required)
     * @param  string $field_name field_name (required)
     * @param  string $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function setTriggerParameter($bt_locator, $trigger_locator, $field_name, $body = null)
    {
        list($response) = $this->setTriggerParameterWithHttpInfo($bt_locator, $trigger_locator, $field_name, $body);
        return $response;
    }

    /**
     * Operation setTriggerParameterWithHttpInfo
     *
     * Update a parameter of a trigger of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function setTriggerParameterWithHttpInfo($bt_locator, $trigger_locator, $field_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->setTriggerParameterRequest($bt_locator, $trigger_locator, $field_name, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setTriggerParameterAsync
     *
     * Update a parameter of a trigger of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setTriggerParameterAsync($bt_locator, $trigger_locator, $field_name, $body = null)
    {
        return $this->setTriggerParameterAsyncWithHttpInfo($bt_locator, $trigger_locator, $field_name, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setTriggerParameterAsyncWithHttpInfo
     *
     * Update a parameter of a trigger of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setTriggerParameterAsyncWithHttpInfo($bt_locator, $trigger_locator, $field_name, $body = null)
    {
        $returnType = 'string';
        $request = $this->setTriggerParameterRequest($bt_locator, $trigger_locator, $field_name, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setTriggerParameter'
     *
     * @param  string $bt_locator (required)
     * @param  string $trigger_locator (required)
     * @param  string $field_name (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setTriggerParameterRequest($bt_locator, $trigger_locator, $field_name, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling setTriggerParameter'
            );
        }
        // verify the required parameter 'trigger_locator' is set
        if ($trigger_locator === null || (is_array($trigger_locator) && count($trigger_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trigger_locator when calling setTriggerParameter'
            );
        }
        // verify the required parameter 'field_name' is set
        if ($field_name === null || (is_array($field_name) && count($field_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_name when calling setTriggerParameter'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/triggers/{triggerLocator}/{fieldName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($trigger_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'triggerLocator' . '}',
                ObjectSerializer::toPathValue($trigger_locator),
                $resourcePath
            );
        }
        // path params
        if ($field_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldName' . '}',
                ObjectSerializer::toPathValue($field_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateBuildParameterOfBuildType
     *
     * Update build parameter.
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  \Swagger\Client\Model\Property $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Property
     */
    public function updateBuildParameterOfBuildType($name, $bt_locator, $body = null, $fields = null)
    {
        list($response) = $this->updateBuildParameterOfBuildTypeWithHttpInfo($name, $bt_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation updateBuildParameterOfBuildTypeWithHttpInfo
     *
     * Update build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Property, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBuildParameterOfBuildTypeWithHttpInfo($name, $bt_locator, $body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Property';
        $request = $this->updateBuildParameterOfBuildTypeRequest($name, $bt_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Property',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateBuildParameterOfBuildTypeAsync
     *
     * Update build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBuildParameterOfBuildTypeAsync($name, $bt_locator, $body = null, $fields = null)
    {
        return $this->updateBuildParameterOfBuildTypeAsyncWithHttpInfo($name, $bt_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateBuildParameterOfBuildTypeAsyncWithHttpInfo
     *
     * Update build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBuildParameterOfBuildTypeAsyncWithHttpInfo($name, $bt_locator, $body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Property';
        $request = $this->updateBuildParameterOfBuildTypeRequest($name, $bt_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateBuildParameterOfBuildType'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\Property $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateBuildParameterOfBuildTypeRequest($name, $bt_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling updateBuildParameterOfBuildType'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling updateBuildParameterOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateBuildParameterSpecificationOfBuildType
     *
     * Update build parameter specification.
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  string $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function updateBuildParameterSpecificationOfBuildType($name, $bt_locator, $body = null)
    {
        list($response) = $this->updateBuildParameterSpecificationOfBuildTypeWithHttpInfo($name, $bt_locator, $body);
        return $response;
    }

    /**
     * Operation updateBuildParameterSpecificationOfBuildTypeWithHttpInfo
     *
     * Update build parameter specification.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBuildParameterSpecificationOfBuildTypeWithHttpInfo($name, $bt_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->updateBuildParameterSpecificationOfBuildTypeRequest($name, $bt_locator, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateBuildParameterSpecificationOfBuildTypeAsync
     *
     * Update build parameter specification.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBuildParameterSpecificationOfBuildTypeAsync($name, $bt_locator, $body = null)
    {
        return $this->updateBuildParameterSpecificationOfBuildTypeAsyncWithHttpInfo($name, $bt_locator, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateBuildParameterSpecificationOfBuildTypeAsyncWithHttpInfo
     *
     * Update build parameter specification.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBuildParameterSpecificationOfBuildTypeAsyncWithHttpInfo($name, $bt_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->updateBuildParameterSpecificationOfBuildTypeRequest($name, $bt_locator, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateBuildParameterSpecificationOfBuildType'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateBuildParameterSpecificationOfBuildTypeRequest($name, $bt_locator, $body = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling updateBuildParameterSpecificationOfBuildType'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling updateBuildParameterSpecificationOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters/{name}/type/rawValue';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateBuildParameterTypeOfBuildType
     *
     * Update type of build parameter.
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  \Swagger\Client\Model\Type $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Type
     */
    public function updateBuildParameterTypeOfBuildType($name, $bt_locator, $body = null)
    {
        list($response) = $this->updateBuildParameterTypeOfBuildTypeWithHttpInfo($name, $bt_locator, $body);
        return $response;
    }

    /**
     * Operation updateBuildParameterTypeOfBuildTypeWithHttpInfo
     *
     * Update type of build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\Type $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Type, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBuildParameterTypeOfBuildTypeWithHttpInfo($name, $bt_locator, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Type';
        $request = $this->updateBuildParameterTypeOfBuildTypeRequest($name, $bt_locator, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Type',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateBuildParameterTypeOfBuildTypeAsync
     *
     * Update type of build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\Type $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBuildParameterTypeOfBuildTypeAsync($name, $bt_locator, $body = null)
    {
        return $this->updateBuildParameterTypeOfBuildTypeAsyncWithHttpInfo($name, $bt_locator, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateBuildParameterTypeOfBuildTypeAsyncWithHttpInfo
     *
     * Update type of build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\Type $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBuildParameterTypeOfBuildTypeAsyncWithHttpInfo($name, $bt_locator, $body = null)
    {
        $returnType = '\Swagger\Client\Model\Type';
        $request = $this->updateBuildParameterTypeOfBuildTypeRequest($name, $bt_locator, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateBuildParameterTypeOfBuildType'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\Type $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateBuildParameterTypeOfBuildTypeRequest($name, $bt_locator, $body = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling updateBuildParameterTypeOfBuildType'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling updateBuildParameterTypeOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters/{name}/type';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateBuildParameterValueOfBuildType
     *
     * Update value of build parameter.
     *
     * @param  string $name name (required)
     * @param  string $bt_locator bt_locator (required)
     * @param  string $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function updateBuildParameterValueOfBuildType($name, $bt_locator, $body = null)
    {
        list($response) = $this->updateBuildParameterValueOfBuildTypeWithHttpInfo($name, $bt_locator, $body);
        return $response;
    }

    /**
     * Operation updateBuildParameterValueOfBuildTypeWithHttpInfo
     *
     * Update value of build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBuildParameterValueOfBuildTypeWithHttpInfo($name, $bt_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->updateBuildParameterValueOfBuildTypeRequest($name, $bt_locator, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateBuildParameterValueOfBuildTypeAsync
     *
     * Update value of build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBuildParameterValueOfBuildTypeAsync($name, $bt_locator, $body = null)
    {
        return $this->updateBuildParameterValueOfBuildTypeAsyncWithHttpInfo($name, $bt_locator, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateBuildParameterValueOfBuildTypeAsyncWithHttpInfo
     *
     * Update value of build parameter.
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBuildParameterValueOfBuildTypeAsyncWithHttpInfo($name, $bt_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->updateBuildParameterValueOfBuildTypeRequest($name, $bt_locator, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateBuildParameterValueOfBuildType'
     *
     * @param  string $name (required)
     * @param  string $bt_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateBuildParameterValueOfBuildTypeRequest($name, $bt_locator, $body = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling updateBuildParameterValueOfBuildType'
            );
        }
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling updateBuildParameterValueOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters/{name}/value';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateBuildParametersOfBuildType
     *
     * Update build parameters.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  \Swagger\Client\Model\Properties $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Properties
     */
    public function updateBuildParametersOfBuildType($bt_locator, $body = null, $fields = null)
    {
        list($response) = $this->updateBuildParametersOfBuildTypeWithHttpInfo($bt_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation updateBuildParametersOfBuildTypeWithHttpInfo
     *
     * Update build parameters.
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Properties, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBuildParametersOfBuildTypeWithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Properties';
        $request = $this->updateBuildParametersOfBuildTypeRequest($bt_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Properties',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateBuildParametersOfBuildTypeAsync
     *
     * Update build parameters.
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBuildParametersOfBuildTypeAsync($bt_locator, $body = null, $fields = null)
    {
        return $this->updateBuildParametersOfBuildTypeAsyncWithHttpInfo($bt_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateBuildParametersOfBuildTypeAsyncWithHttpInfo
     *
     * Update build parameters.
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBuildParametersOfBuildTypeAsyncWithHttpInfo($bt_locator, $body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Properties';
        $request = $this->updateBuildParametersOfBuildTypeRequest($bt_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateBuildParametersOfBuildType'
     *
     * @param  string $bt_locator (required)
     * @param  \Swagger\Client\Model\Properties $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateBuildParametersOfBuildTypeRequest($bt_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling updateBuildParametersOfBuildType'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateBuildTypeVcsRoot
     *
     * Update a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $vcs_root_locator vcs_root_locator (required)
     * @param  \Swagger\Client\Model\VcsRootEntry $body body (optional)
     * @param  string $fields fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\VcsRootEntry
     */
    public function updateBuildTypeVcsRoot($bt_locator, $vcs_root_locator, $body = null, $fields = null)
    {
        list($response) = $this->updateBuildTypeVcsRootWithHttpInfo($bt_locator, $vcs_root_locator, $body, $fields);
        return $response;
    }

    /**
     * Operation updateBuildTypeVcsRootWithHttpInfo
     *
     * Update a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  \Swagger\Client\Model\VcsRootEntry $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\VcsRootEntry, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBuildTypeVcsRootWithHttpInfo($bt_locator, $vcs_root_locator, $body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\VcsRootEntry';
        $request = $this->updateBuildTypeVcsRootRequest($bt_locator, $vcs_root_locator, $body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\VcsRootEntry',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateBuildTypeVcsRootAsync
     *
     * Update a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  \Swagger\Client\Model\VcsRootEntry $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBuildTypeVcsRootAsync($bt_locator, $vcs_root_locator, $body = null, $fields = null)
    {
        return $this->updateBuildTypeVcsRootAsyncWithHttpInfo($bt_locator, $vcs_root_locator, $body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateBuildTypeVcsRootAsyncWithHttpInfo
     *
     * Update a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  \Swagger\Client\Model\VcsRootEntry $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBuildTypeVcsRootAsyncWithHttpInfo($bt_locator, $vcs_root_locator, $body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\VcsRootEntry';
        $request = $this->updateBuildTypeVcsRootRequest($bt_locator, $vcs_root_locator, $body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateBuildTypeVcsRoot'
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  \Swagger\Client\Model\VcsRootEntry $body (optional)
     * @param  string $fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateBuildTypeVcsRootRequest($bt_locator, $vcs_root_locator, $body = null, $fields = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling updateBuildTypeVcsRoot'
            );
        }
        // verify the required parameter 'vcs_root_locator' is set
        if ($vcs_root_locator === null || (is_array($vcs_root_locator) && count($vcs_root_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vcs_root_locator when calling updateBuildTypeVcsRoot'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs-root-entries/{vcsRootLocator}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($vcs_root_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'vcsRootLocator' . '}',
                ObjectSerializer::toPathValue($vcs_root_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xml', 'application/json'],
                ['application/xml', 'application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateBuildTypeVcsRootCheckoutRules
     *
     * Update checkout rules of a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator bt_locator (required)
     * @param  string $vcs_root_locator vcs_root_locator (required)
     * @param  string $body body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function updateBuildTypeVcsRootCheckoutRules($bt_locator, $vcs_root_locator, $body = null)
    {
        list($response) = $this->updateBuildTypeVcsRootCheckoutRulesWithHttpInfo($bt_locator, $vcs_root_locator, $body);
        return $response;
    }

    /**
     * Operation updateBuildTypeVcsRootCheckoutRulesWithHttpInfo
     *
     * Update checkout rules of a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  string $body (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateBuildTypeVcsRootCheckoutRulesWithHttpInfo($bt_locator, $vcs_root_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->updateBuildTypeVcsRootCheckoutRulesRequest($bt_locator, $vcs_root_locator, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateBuildTypeVcsRootCheckoutRulesAsync
     *
     * Update checkout rules of a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBuildTypeVcsRootCheckoutRulesAsync($bt_locator, $vcs_root_locator, $body = null)
    {
        return $this->updateBuildTypeVcsRootCheckoutRulesAsyncWithHttpInfo($bt_locator, $vcs_root_locator, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateBuildTypeVcsRootCheckoutRulesAsyncWithHttpInfo
     *
     * Update checkout rules of a VCS root of the matching build configuration.
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBuildTypeVcsRootCheckoutRulesAsyncWithHttpInfo($bt_locator, $vcs_root_locator, $body = null)
    {
        $returnType = 'string';
        $request = $this->updateBuildTypeVcsRootCheckoutRulesRequest($bt_locator, $vcs_root_locator, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateBuildTypeVcsRootCheckoutRules'
     *
     * @param  string $bt_locator (required)
     * @param  string $vcs_root_locator (required)
     * @param  string $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateBuildTypeVcsRootCheckoutRulesRequest($bt_locator, $vcs_root_locator, $body = null)
    {
        // verify the required parameter 'bt_locator' is set
        if ($bt_locator === null || (is_array($bt_locator) && count($bt_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bt_locator when calling updateBuildTypeVcsRootCheckoutRules'
            );
        }
        // verify the required parameter 'vcs_root_locator' is set
        if ($vcs_root_locator === null || (is_array($vcs_root_locator) && count($vcs_root_locator) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $vcs_root_locator when calling updateBuildTypeVcsRootCheckoutRules'
            );
        }

        $resourcePath = '/app/rest/buildTypes/{btLocator}/vcs-root-entries/{vcsRootLocator}/checkout-rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bt_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'btLocator' . '}',
                ObjectSerializer::toPathValue($bt_locator),
                $resourcePath
            );
        }
        // path params
        if ($vcs_root_locator !== null) {
            $resourcePath = str_replace(
                '{' . 'vcsRootLocator' . '}',
                ObjectSerializer::toPathValue($vcs_root_locator),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain'],
                ['text/plain']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
